캐시 메모리의 필요성
--------------------------------
- CPU가 RAM에서 데이터를 바로 가져오면 되는데, 왜 캐시 메모리가 추가로 필요할까요?
- 이는 CPU의 속도가 매우 빠른데 반해, RAM은 상대적으로 느리기 때문입니다.

- 만약 CPU가 매번 느린 RAM을 기다려야 한다면?
- 이는, CPU가 놀게 되서 성능이 떨어지고 시간이 낭비되게 될 것입니다.

캐시 메모리(Cache)
----------------------------------
- 캐시 메모리는 RAM보다 훨씬 빠른 작은 저장 공간을 말합니다.
- CPU 가까이에 위치해서 보통은 L1, L2, L3 캐시로 계층화 합니다.
- 원리는 자주 쓰는 데이터를 캐시에 미리 복사해둔 다음, CPU가 RAM이 아닌 캐시에서 먼저 읽도록 함으로써 구현됩니다.

- 비유하자면 책상에서 공부할 때 책장에 있는 책을 매번 가서 꺼내기 귀찮다면, 자주 쓰는 책을 책상 위에 올려두는 것과 같습니다.

캐시 메모리 작동 순서
---------------------------------
- CPU가 데이터가 필요한 경우, 캐시를 먼저 확인합니다.
- 캐시 히트 : 이 때, CPU가 필요한 데이터를 캐시에서 찾은 경우를 캐시 히트라고 합니다.
  
- 캐시 미스 : 캐시에 찾는 데이터가 없는 경우를 캐시 미스라고 합니다.
- 이 때는 RAM까지 가서 데이터를 읽어와서 캐시에 저장합니다.

캐시 계층 구조
----------------------------------
<table border="1">
  <thead>
    <tr>
      <th>계층</th>
      <th>위치</th>
      <th>속도</th>
      <th>용량</th>
      <th>특징</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>L1 캐시</td>
      <td>CPU 코어 내부</td>
      <td>가장 빠름</td>
      <td>작음 (32KB ~ 64KB)</td>
      <td>즉시 사용</td>
    </tr>
    <tr>
      <td>L2 캐시</td>
      <td>CPU 코어 근처</td>
      <td>빠름</td>
      <td>중간 (256KB ~ 512KB)</td>
      <td>백업</td>
    </tr>
    <tr>
      <td>L3 캐시</td>
      <td>CPU 전체에서 공유</td>
      <td>L1, L2보다 느림</td>
      <td>큼 (수 MB 이상)</td>
      <td>코어 간 데이터 공유</td>
    </tr>
  </tbody>
</table>

캐시 미스의 종류
---------------------------------------
<table border="1">
  <thead>
    <tr>
      <th>종류</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Cold Miss (Compulsory Miss)</td>
      <td>처음 접근하는 데이터라 캐시에 없음</td>
    </tr>
    <tr>
      <td>Capacity Miss</td>
      <td>캐시 용량 부족으로 필요한 데이터를 담지 못함</td>
    </tr>
    <tr>
      <td>Conflict Miss</td>
      <td>매핑 충돌로 인해 기존 데이터가 밀려남</td>
    </tr>
  </tbody>
</table>

캐시 일관성 문제(Cache Coherency)
-------------------------------------------
- 멀티코어 CPU에서 여러 캐시가 동일한 데이터를 서로 다르게 갖고 있는 문제를 캐시 일관성 문제라고 합니다.
- 즉, 데이터 값이 달라짐으로 인해 심각한 오류가 발생할 가능성이 있습니다.

- 예를 들어 CPU1은 변수 x = 10 -> 20으로 바꿨는데, CPU2는 여전히 x = 10이라고 믿고 연산하면 논리 오류가 발생할 것입니다.

MESI 프로토콜
-----------------------------------------
- 캐시 일관성 문제를 해결하기 위해, 캐시가 가진 데이터 상태를 관리하는 프로토콜을 MESI 프로토콜이라고 합니다.

<table border="1">
  <thead>
    <tr>
      <th>상태</th>
      <th>의미</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>M (Modified)</td>
      <td>캐시가 데이터를 수정했고, RAM과 불일치함</td>
    </tr>
    <tr>
      <td>E (Exclusive)</td>
      <td>캐시가 유일하게 데이터를 가지고 있고, RAM과 동일함</td>
    </tr>
    <tr>
      <td>S (Shared)</td>
      <td>여러 캐시가 같은 데이터를 가지고 있고, RAM과 동일함</td>
    </tr>
    <tr>
      <td>I (Invalid)</td>
      <td>이 캐시의 데이터는 무효이며, 더 이상 유효하지 않음</td>
    </tr>
  </tbody>
</table>

- 이러한 프로토콜을 통해 캐시 간에 버스 트랜잭션을 통해 신호를 주고 받습니다.
- 누가 데이터를 수정하면 다른 캐시의 값을 무효화시키게 됩니다.

Bus snopping
-----------------------------------
- 캐시의 신호 전달은, M/E/S/I 같은 상태 코드가 직접 전달되는 것이 아닙니다.
- 전달되는 건 "내가 이 메모리를 수정하겠다"와 같은 버스 신호가 전달됩니다. ( 브로드 캐스트 방식 )
- 모든 캐시가 공통 버스를 통해 신호를 감지하는 것을 바로 Bus snopping이라고 합니다.

  
