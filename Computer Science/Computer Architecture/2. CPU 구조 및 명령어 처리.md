CPU 구조 
--------------------------------------------------------
<table>
  <tr>
    <th>구성 요소</th>
    <th>역할</th>
  </tr>
  <tr>
    <th>연산 장치(ALU)</th>
    <td>덧셈, 뺄셈, 논리 연산(AND, OR 등)을 수행합니다.</td>
  </tr>
  <tr>
    <th>제어 장치(CU)</th>
    <td>명령어를 해석하고 실행을 제어합니다. 명령어 사이클을 관리합니다.</td>
  </tr>
  <tr>
    <th>레지스터(Register)</th>
    <td>데이터를 임시로 저장하는 초고속 메모리입니다. 연산 결과나 주소를 보관합니다.</td>
  </tr>
  <tr>
    <th>프로그램 카운터(PC)</th>
    <td>다음 명령어의 메모리 주소를 보관합니다.</td>
  </tr>
  <tr>
    <th>명령어 레지스터(IR)</th>
    <td>현재 실행 중인 명령어를 보관합니다.</td>
  </tr>
</table>

명령어 처리 과정 ( 명령어 사이클 )
--------------------------------------------------------------
CPU는 명령어를 처리할 때 다음 4가지 단계를 반복 수행합니다.
1. 인출(Fetch) : 메모리에서 명령어를 가져옵니다.
- 인출 단계에서는 PC(프로그램 카운터)가 가리키는 주소에서 명령어를 읽어와서 IR(명령어 레지스터)에 저장합니다.

2. 해독(Decode) : 명령어를 해석하여 어떤 작업을 수행할 지 파악합니다.
- 연산 코드와 피연산자 정보를 추출하는 단계입니다.

3. 실행(Execute) : ALU에서 연산을 수행하거나, 데이터 이동 또는 제어 명령을 실행합니다.
 
4. 저장(Store) : 연산 결과를 레지스터나 메모리에 저장합니다.
- 이후 다음 명령어 실행을 위해서 PC를 증가시킵니다.

JAVA 코드로 이해하는 명령어 처리 절차
----------------------------------------------------
```java
import java.io.*;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        // 1. 인출 (Fetch)
        // 명령어들이 메모리에 저장되어 있습니다.
        String[] instructions = {"LOAD R1, 5", "ADD R1, 10", "STORE R1, 100"};
        // 프로그램 카운터 역할을 할 변수입니다.
        int pc = 0;

        // 모든 명령어를 읽을 때까지 수행합니다.
        while(pc < instructions.length) {
            // 2. 해독(Decode)
            String instruction = instructions[pc];
            System.out.println("인출: " + instruction);
            String[] parts = instruction.split(" ");
            
            // 3. 실행(Execute)
            switch (parts[0]) {
                case "LOAD":
                    System.out.println("레지스터 " + parts[1] + "에 값" + parts[2] + " 로드");
                    break;
                case "ADD":
                    System.out.println("레지스터 " + parts[1] + "에 값" + parts[2] + " 더하기");
                    break;
                case "STORE":
                    System.out.println("주소 " + parts[2] + "에 값 저장");
                    break;
                default:
                    System.out.println("알 수 없는 명령어");
            }

            // 저장(Store)
            pc++; // 다음 명령어로 이동합니다.
        }
    }
}
```

파이프라이닝(Pipelining)
---------------------------------------------------
- 여러 명령어를 겹쳐서 동시에 처리해서 성능을 극대화하는 기법을 파이프라이닝이라고 합니다.
- 파이프라이닝을 적용하면 일을 순서대로 처리하는 것이 아니라, 동시에 겹쳐서 하게 됩니다.
- 즉 파이프라이닝을 통하면 명령어 사이클을 동시에 진행해서 CPU 성능을 향상시킬 수 있습니다.

<table>
  <tr>
    <th>단계</th>
    <th>명령어1</th>
    <th>명령어2</th>
    <th>명령어3</th>
  </tr>
  <tr>
    <th>인출(F)</th>
    <td>O</td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <th>해독(D)</th>
    <td>O</td>
    <td>O</td>
    <td></td>
  </tr>
  <tr>
    <th>실행(E)</th>
    <td>O</td>
    <td>O</td>
    <td>O</td>
  </tr>
</table>

파이프라이닝 이해를 위한 예시
----------------------------------------------
- 햄버거 가게에서 주문을 받는 것과 파이프라이닝은 유사합니다.
- 주문 받기 -> 재료 준비 -> 요리 -> 포장의 단계로 이루어질 때 파이프라이닝을 적용하게 되면
- 재료를 준비하면서 다음 주문도 처리하고, 요리하면서 포장도 할 수 있게 됩니다.
- 단, 앞의 명령이 완료되지 못하면 뒤의 명령이 기다려야 하는 병목이 발생할 수 있습니다. ( 고기 굽는 게 오래 걸리면 그 다음 햄버거가 나올 때까지 시간이 지연됩니다. )

파이프라이닝의 핵심
------------------------------------------------
- 파이프라이닝의 핵심은 한 명령어의 각 단계를 나눠서 겹쳐 실행하는 것입니다.
- 예를 들면, 첫 명령어가 인출 단계에 있다면 두 번째 명령어는 해독 단계로 들어가고, 세 번째 명령어는 실행 단계로 접어드는 것과 같은 방식입니다.
- 하나의 코어에서도 여러 명령어를 겹쳐서 처리할 수 있는 것이 핵심입니다. ( 멀티코어와는 다릅니다. )

파이프라이닝이 가능한 이유
----------------------------------
이는 각 단계가 서로 다른 자원(Resource)를 사용하기 때문에 독립적으로 실행이 가능합니다.
- 인출(Fetch)는 '버스'를 통해 메모리에 접근하고,
- 해독(Decode)는 'CU'를 통해 명령어를 해석하고,
- 실행(Execute)는 'ALU'를 사용해서 연산을 수행하고,
- 저장(Store)는 메모리나 레지스터에 접근함으로써 저장이 가능합니다.

파이프라이닝의 장단점
---------------------------------------------
- 장점 : 명령어들을 겹쳐 처리하기 때문에 처리 속도가 증가하고 CPU 자원 활용을 극대화할 수 있습니다.
- 단점 : 데이터 및 제어에 대한 의존성이 생길 수 있습니다. 명령어들끼리 간섭 및 순서가 꼬여 CPU 성능이 저하되는 파이프라인 해저드가 발생할 수 있습니다.
