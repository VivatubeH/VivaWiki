# Java 문자열 처리

## 핵심 개념
- String은 **불변 객체**이므로 + 연산으로 문자열을 계속 이어붙이면 매번 새로운 객체가 생성되어 **시간 초과 발생**
- 문자열 조작이 많은 문제는 **StringBuilder** 사용 필수
- 시간복잡도: String + 연산 반복 시 O(N²), StringBuilder는 O(N)

## 자주 쓰는 String 메서드 (코테용)
```java
String str = "Hello Java";

// 1. 길이, 문자 접근
int len = str.length();              // 길이
char ch = str.charAt(0);             // 0번째 문자

// 2. 문자열 비교
boolean equal = str.equals("Hello"); // 내용 비교 (== 절대 사용 금지)
int compare = str.compareTo("Abc");  // 사전순 비교 (양수/0/음수)

// 3. 검색
int idx = str.indexOf('a');          // 문자 첫 등장 위치 (-1이면 없음)
boolean has = str.contains("Java");  // 포함 여부

// 4. 추출/변환
String sub = str.substring(0, 5);    // [0, 5) 추출 -> "Hello"
char[] arr = str.toCharArray();      // char 배열로 변환
String lower = str.toLowerCase();    // 소문자 변환
String upper = str.toUpperCase();    // 대문자 변환

// 5. 분리/결합
String[] parts = str.split(" ");     // 공백 기준 분리
String joined = String.join("-", parts); // 배열을 "-"로 결합

// 6. 공백/검증
String trimmed = str.trim();         // 앞뒤 공백 제거
boolean empty = str.isEmpty();       // 길이 0인지 체크
boolean blank = str.isBlank();       // 공백만 있는지 체크 (Java 11+)

// 7. 접두사/접미사
boolean start = str.startsWith("He"); // "He"로 시작하는지
boolean end = str.endsWith(".java");  // ".java"로 끝나는지

// 8. 정규표현식
String noDigit = str.replaceAll("[0-9]", ""); // 숫자 제거
```

## StringBuilder 핵심 메서드 (필수 암기)
```java
StringBuilder sb = new StringBuilder();

// 1. 추가/삭제
sb.append("Hello");        // 끝에 추가 (가장 많이 씀)
sb.insert(5, " Java");     // index 5 앞에 삽입
sb.delete(5, 10);          // [5, 10) 범위 삭제
sb.deleteCharAt(0);        // 0번째 문자 삭제

// 2. 변경
sb.replace(0, 5, "Hi");    // [0, 5) 범위를 "Hi"로 교체
sb.setCharAt(0, 'h');      // 0번째 문자를 'h'로 변경

// 3. 뒤집기
sb.reverse();              // 문자열 뒤집기 (팰린드롬 체크 등에 유용)

// 4. 변환/초기화
String result = sb.toString();  // String으로 변환
sb.setLength(0);                // 초기화 (새로운 객체 생성 X, 효율적)

// 5. 길이
int len = sb.length();          // 현재 길이
```

## 문자열 <-> 숫자 변환 (자주 나옴)
```java
// 숫자 -> 문자열
int num = 123;
String str1 = String.valueOf(num);   // 가장 빠름 (권장)
String str2 = Integer.toString(num); // 이것도 OK
String str3 = "" + num;              // 비추 (느림)

// 문자열 -> 숫자
String str = "456";
int n1 = Integer.parseInt(str);      // 10진수 변환
int n2 = Integer.parseInt("1010", 2); // 2진수 문자열을 10진수로 변환 (진법 변환)

// char -> int (숫자 문자)
char ch = '5';
int digit = ch - '0';  // '5' - '0' = 5 (ASCII 차이 이용)
```

## StringTokenizer (split보다 빠름)
```java
import java.util.StringTokenizer;

String input = "apple banana orange";

// split 방식 (정규식 사용 -> 느림)
String[] arr = input.split(" ");

// StringTokenizer 방식 (권장, 약 2배 빠름)
StringTokenizer st = new StringTokenizer(input, " "); // 구분자 " "
while (st.hasMoreTokens()) {
    String token = st.nextToken(); // 토큰 하나씩 추출
}

// 토큰 개수 미리 확인
int count = st.countTokens();
```

## 실수하기 쉬운 포인트

### 1. == 비교 금지
```java
String s1 = "hello";
String s2 = "hello";
String s3 = new String("hello");

s1 == s2;        // true (같은 상수 풀 참조)
s1 == s3;        // false (다른 객체)
s1.equals(s3);   // true (항상 equals 사용!)
```

### 2. StringBuilder equals 오버라이딩 안 됨
```java
StringBuilder sb1 = new StringBuilder("hello");
StringBuilder sb2 = new StringBuilder("hello");

sb1.equals(sb2); // false! (주소 비교)

// 올바른 비교
sb1.toString().equals(sb2.toString()); // true
```

### 3. substring 범위 [start, end)
```java
String str = "Hello";
str.substring(0, 3); // "Hel" (3번째 인덱스 미포함)
```

### 4. insert/delete 후 인덱스 변화 주의
```java
StringBuilder sb = new StringBuilder("abc");
sb.insert(1, "X");  // "aXbc"
sb.delete(1, 2);    // "abc" (X가 삭제되며 인덱스가 당겨짐!)
```

## 문제 유형별 활용

| 유형 | 사용 메서드 | 예시 문제 |
|------|------------|----------|
| 문자열 뒤집기 | `StringBuilder.reverse()` | 팰린드롬 |
| 문자 개수 세기 | `toCharArray()` + 배열 | 애너그램 |
| 부분 문자열 | `substring()`, `indexOf()` | KMP 대신 |
| 문자열 조작 | `StringBuilder` | 괄호 추가/제거 |
| 공백 처리 | `trim()`, `split()` | 입력 파싱 |
| 진법 변환 | `Integer.parseInt(str, n)` | 2진수/8진수 |

## 디버깅 팁
- `StringBuilder` 중간 결과 확인: `System.out.println(sb.toString())`
- 문자열 길이 체크: `isEmpty()` vs `isBlank()` 구분
- 인덱스 범위: `charAt()`, `substring()` 사용 전 범위 검증
- 정규식 테스트: https://regexr.com/ 에서 미리 확인
