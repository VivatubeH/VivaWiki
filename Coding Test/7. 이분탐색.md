## 이분 탐색
- **정렬되어 있는 집합**에서 원하는 값을 찾는 효율적인 탐색 방법

#### 선형 탐색 vs 이분 탐색의 시간 복잡도

- **선형 탐색** : 모든 원소를 하나하나 선형적으로 탐색하기 때문에 시간 복잡도 O(N)
```java
boolean isExist(int[] arr, int X) {
    for (int a : arr) {
        if (a == X) return true;
    }
    return false;
}
```

-**이분 탐색** : 조사 범위를 절반씩 줄여가며 탐색하기 때문에 **시간 복잡도 O(log N)**
```java
boolean isExist(int[] arr, int X) {
    int l = 0, r = arr.length - 1;
    while (l <= r) {
        int m = (l + r) / 2;
        if (arr[m] < X) l = m + 1;
        else if (arr[m] > X) r = m - 1;
        else return true;
    }
    return false;
}
```
<img width="435" height="243" alt="image" src="https://github.com/user-attachments/assets/14876a04-8f81-4ebb-b632-9d43bcd2ccd8" />

- 이분 탐색은 **탐색 범위가 절반씩 줄어들기 때문에** 성능이 뛰어나다.

#### Tip. 이분 탐색 시 오버플로우 방지하기
- `int m = (l + r) / 2`는 **l과 r이 매우 클 경우 오버플로우**가 발생할 우려가 있다.
- `int m = l + (r - 1) / 2`로 사용하는 것이 오버플로우를 방지하기에 좋다. **( 둘은 수학적으로 동일한 식이다. )**

#### 이분 탐색의 전제 조건
- **반드시 데이터가 오름차순 또는 내림차순 정렬되어 있어야만 한다.**

#### 이분 탐색 시 개수를 찾아야 할 때 -> **반 열린 구간** 
- lowerBound : 해당 수의 **이상인 수가 등장하는 첫 위치**
- upperBound : 해당 수를 **초과하는 수가 등장하는 첫 위치**
- `[Lower, Upper)` (Lower는 포함, Upper는 미포함) 사용
- `길이(개수) = Uppper - lower`이 된다.
- **값이 있을 때** : upperBound - lowerBound가 개수가 된다.
- **값이 없을 때** : upperBound == lowerBound가 되어서 0이 된다.

#### while (left < right), right = size 이해하기
- 숫자가 아닌, **숫자 사이의 칸막이를 찾는다**
- `[1, 2, 3, 4, 5]`를 `| 1 | 2 | 3 | 4 | 5 |`로 생각해본다.
- 배열의 끝은 **size-1**이지만, 칸막이는 **size**까지 존재한다.
- `left < right`는 **두 칸막이 사이에 숫자가 하나라도 있는지?** 체크
- 칸막이의 사이는 **숫자가 들어갈 수 있는 공간**으로 본다.

#### Lower Bound
```java
public static int lowerBound(List<Integer> list, int target) {
    int left = 0; // 가장 왼쪽 칸막이
    int right = list.size(); // 가장 오른쪽 칸막이

    while (left < right) { // 두 칸막이 사이에 숫자가 있다면 계속 반복
        int mid = (left + right) / 2;

        // 중앙 숫자가 target보다 크거나 같으면?
        // -> 적어도 mid번째 칸막이 혹은 그 왼쪽이 우리가 찾는 시작점이 된다.
        if (list.get(mid) >= target) { // mid번째 칸막이 뒤의 숫자가 target보다 크면
            right = mid; // 오른쪽 칸막이를 mid로 당긴다.
        } 
        // 중앙 숫자가 target보다 작다면?
        // -> mid번째 칸막이와 그 왼쪽은 절대 답이 될 수 없다.
        else {
            left = mid + 1; // 왼쪽 칸막이를 mid 다음으로 밀어낸다.
        }
    }
    // left와 right가 만나는 지점 = target 이상의 값이 시작되는 '최초의 칸막이'
    return left; 
}
```

#### Upper Bound
```java
public static int upperBound(List<Integer> list, int target) {
    int left = 0; // 가장 왼쪽 칸막이
    int right = list.size(); // 가장 오른쪽 칸막이

    while (left < right) { // 두 칸막이 사이에 숫자가 있는 동안 반복
        int mid = (left + right) / 2;

        // 중앙 숫자가 타겟보다 크면?
        // -> 적어도 mid번째 칸막이 혹은 그 이전이 초과 지점의 시작이다.
        if (list.get(mid) > target) {
            right = mid; // 오른쪽 칸막이를 mid로 당긴다.
        } 
        // 중앙 숫자가 타켓보다 작다면?
        // -> mid번째 칸막이와 그 왼쪽이 절대 답이 될 수 없다.
        else {
            left = mid + 1;
        }
    }
    // left와 right가 만나는 지점 = target 이상의 값이 시작되는 '최적의 칸막이'
    return left;
}
```
