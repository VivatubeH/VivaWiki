# 시간 복잡도
- 입력 크기와 알고리즘간의 관계 ( 입력 크기에 대해 프로그램의 동작 시간을 가늠하는 수단 )
- 대략 1초에 약 1억번 연산을 기준으로 소요시간을 가늠한다. ( 넉넉하게 1천만번으로 생각하는 게 편함 )

### Java의 시간 제한 고려
- 같은 알고리즘이어도 언어마다 동작 시간이 상이하다.
- Java는 컴파일 방식 + 인터프리터 방식이 동시에 동작하기 때문에 속도가 느린편이다. ( 그래서 보통 보정값이 적용된다. )
- 특히, 시간 제한이 1초 미만으로 타이트할 때는 복잡도 외에도 BufferedReader, BufferedWriter를 사용한 입출력 최적화가 필수적이다.

### 주요 시간 복잡도
- O(1) : 입력값과 상관없이 즉시 실행된다.
- O(log N) : 로그 시간, 즉 연산마다 실행 시간이 절반씩 줄어든다. ( 대표적으로 이진 탐색 )
- O(N) : 데이터를 한 번씩만 훑게 된다. ( 대표적으로 단순 반복문 )
- O(N log N) : 보통의 정렬 알고리즘의 표준이 되는 시간 복잡도이다. ( Arrays.sort() 처럼, 데이터를 반씩 쪼개서 합치는 과정처럼... )
- O(N^2) : 대표적으로 중첩 반복문의 시간 복잡도이다.
- O(2^N) : 지수 시간, 즉 모든 경우의 수를 다 해보는 경우의 시간복잡도이다.
- O(N!) : 팩토리얼 시간, 모든 순열을 구하는 경우 시간 복잡도이다.

### 핵심
- O(N log N) 보다 큰 시간 복잡도는 입력이 크면 시간 초과의 우려가 상당히 있으니 주의해야 한다.
- 알고리즘을 풀 때, 시간 복잡도가 적은 알고리즘을 위주로 생각하고 내가 짤 알고리즘이 시간 제한내에 수행이 가능한지 미리 체크한다.
