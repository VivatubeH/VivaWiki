# 시간 복잡도 (Time Complexity)

## 핵심 개념
입력 크기 N에 따라 알고리즘이 수행하는 연산 횟수를 나타내는 지표.
코딩테스트에서 시간 제한 내에 해결 가능한지 판단하는 핵심 기준.

**기준**: 1초당 약 **1억 번(10^8)** 연산 (안전하게는 **1천만 번(10^7)** 기준)

## Java 특수 상황
```java
// ⚠️ Java는 C/C++보다 2~3배 느림 (JVM 오버헤드)
// 시간 제한 1초 미만일 때 필수 최적화:

import java.io.*;
import java.util.*;

BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
StringTokenizer st = new StringTokenizer(br.readLine());

// ❌ Scanner + System.out.println() → 시간 초과 위험
// ✅ BufferedReader + BufferedWriter → 통과
```

## 주요 시간 복잡도 (빠름 → 느림)

| 복잡도 | 설명 | 대표 알고리즘 | N=10^6일 때 연산 횟수 |
|--------|------|---------------|---------------------|
| **O(1)** | 상수 시간 | 배열 인덱스 접근, 해시맵 조회 | 1 |
| **O(log N)** | 로그 시간 | 이분 탐색, 트리 높이 | ~20 |
| **O(N)** | 선형 시간 | 단순 반복문, 투 포인터 | 10^6 |
| **O(N log N)** | 정렬 표준 | Arrays.sort(), 병합정렬 | ~2천만 |
| **O(N^2)** | 이차 시간 | 중첩 반복문, 버블정렬 | 10^12 (💥) |
| **O(2^N)** | 지수 시간 | 완전탐색(비트마스크) | 불가능 |
| **O(N!)** | 팩토리얼 | 순열 완전탐색 | 불가능 |

### 🎯 실전 판단 기준
```java
// N 크기별 적합한 시간 복잡도

N ≤ 10      → O(N!) 가능
N ≤ 20      → O(2^N) 가능
N ≤ 500     → O(N^3) 가능
N ≤ 3,000   → O(N^2) 가능
N ≤ 100,000 → O(N log N) 필수
N ≤ 1,000,000 → O(N) 또는 O(log N) 필수
```

## 표준 코드 템플릿

### 1. 시간 복잡도 계산 예시
```java
// O(N) - 단순 반복
for (int i = 0; i < n; i++) {
    // 상수 시간 작업
}

// O(N log N) - 정렬
Arrays.sort(arr); // 내부적으로 Dual-Pivot Quicksort

// O(N^2) - 중첩 반복
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        // 상수 시간 작업
    }
}

// O(log N) - 이분 탐색
int left = 0, right = n - 1;
while (left <= right) {
    int mid = (left + right) / 2;
    if (arr[mid] == target) return mid;
    else if (arr[mid] < target) left = mid + 1;
    else right = mid - 1;
}
```

### 2. 시간 복잡도 개선 패턴
```java
// ❌ O(N^2) - 시간 초과 위험
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        if (arr[i] + arr[j] == target) {
            // ...
        }
    }
}

// ✅ O(N) - HashSet 활용
Set<Integer> set = new HashSet<>();
for (int i = 0; i < n; i++) {
    if (set.contains(target - arr[i])) {
        // 찾음!
    }
    set.add(arr[i]);
}
```

## 실수 포인트 & 디버깅 팁

### ⚠️ 자주 하는 실수

1. **숨은 O(N) 간과**

**String 연결의 함정**
```java
// ❌ 실제로는 O(N^3)
for (int i = 0; i < n; i++) {              // N번
    String str = "";
    for (int j = 0; j < n; j++) {          // N번
        str += arr[j];                      // O(j) - 매번 전체 복사!
        // String은 불변이라 연결할 때마다:
        // 1. 새 메모리 할당
        // 2. 기존 str 전체를 새 공간에 복사 ← O(현재 길이)
        // 3. arr[j] 추가
        // 4. 새 String 객체 생성
        // → j=0,1,2,...,n-1 → 복사 횟수: 0+1+2+...+(n-1) = O(N^2)
    }
}
// 총 시간 복잡도: O(N) × O(N^2) = O(N^3)

// ✅ O(N^2)로 개선
for (int i = 0; i < n; i++) {              // N번
    StringBuilder sb = new StringBuilder();
    for (int j = 0; j < n; j++) {          // N번
        sb.append(arr[j]);                  // O(1) - 내부 버퍼 끝에 추가만
        // StringBuilder는 가변이라:
        // 1. 미리 할당된 버퍼 공간에 추가
        // 2. 복사 없이 포인터만 이동
        // 3. 버퍼 부족 시만 2배 확장 (amortized O(1))
    }
}
// 총 시간 복잡도: O(N) × O(N) = O(N^2)
```

**핵심 차이**
| | String += | StringBuilder.append() |
|---|---|---|
| **내부 동작** | 매번 새 객체 생성 + 전체 복사 | 버퍼 끝에 추가만 |
| **복사 횟수** | 0+1+2+...+(n-1) = O(N^2) | 0 (amortized) |
| **각 연산** | O(현재 길이) | O(1) |

**구체적 예시 (n=1000)**
```java
// String += 방식
// 복사 횟수: 0+1+2+...+999 = 499,500번
// → 약 5억 번 연산 (O(N^3) = 10억)

// StringBuilder 방식
// 추가 횟수: 1,000번
// → 약 100만 번 연산 (O(N^2) = 100만)
```

2. **Collections.sort() vs Arrays.sort()**
```java
   // List<Integer> - O(N log N) 보장
   Collections.sort(list);
   
   // int[] - O(N log N) 평균, 최악 O(N^2) 가능 (Quicksort)
   Arrays.sort(primitiveArray); // ⚠️ 특수 케이스 주의
   
   // Integer[] - O(N log N) 보장 (Timsort)
   Arrays.sort(boxedArray); // ✅ 안전
```

### 🔍 디버깅 체크리스트
```java
// 제출 전 필수 확인사항:
1. N 범위 확인 → 예상 연산 횟수 계산
2. 시간 제한 확인 (1초 = 10^8 연산)
3. N^2 알고리즘인데 N > 10,000 → 재설계 필요
4. 문자열 연산 많으면 StringBuilder 사용했는지
5. Arrays.sort() 사용 시 최악 케이스 고려했는지
```

## 면접 대비 핵심

**Q1. 시간 복잡도 O(N log N)인 알고리즘을 O(N)으로 개선할 수 있는 상황은?**
- 해시맵/해시셋 활용 (정렬 대신 O(1) 탐색)
- 투 포인터 (정렬된 배열에서 O(N^2) → O(N))
- 카운팅 정렬 (범위가 작을 때 O(N+K))

**Q2. Java에서 Arrays.sort()가 최악의 경우 느린 이유는?**
- 기본형(int[])은 Dual-Pivot Quicksort 사용
- 최악의 경우 O(N^2) 가능 (pivot 선택 실패 시)
- 참조형(Integer[])은 Timsort로 O(N log N) 보장

**Q3. 문자열 연결(+)이 느린 이유와 해결책은?**
- String은 불변(immutable)이라 연결마다 새 객체 생성 → O(N)
- N번 반복 시 O(N^2) 발생
- StringBuilder 사용으로 O(N) 해결 (내부 버퍼 재사용)

**Q4. 시간 제한 1초, N=100만일 때 적합한 알고리즘은?**
- O(N) 또는 O(N log N)만 가능
- O(N^2)은 10^12 연산으로 100초 소요 → 불가능

**Q5. 재귀 알고리즘 사용 시 주의할 점은?**
- Java 기본 스택 크기 제한 (~5000 깊이)
- N이 크면 반복문 변환 또는 JVM 옵션 조정 필요
- 메모이제이션으로 중복 계산 제거 (DP)
