# 이분 탐색 (Binary Search)

## 핵심 개념
**정렬된 배열**에서 탐색 범위를 절반씩 줄여가며 원하는 값을 찾는 알고리즘.
매 단계마다 탐색 범위가 절반으로 줄어들기 때문에 효율적이다.

**사용 시점**: 정렬된 데이터에서 특정 값을 빠르게 찾거나, 조건을 만족하는 최솟값/최댓값을 구할 때

## 시간/공간 복잡도
- **시간 복잡도**: O(log N) - 매번 범위가 절반씩 줄어듦
- **공간 복잡도**: O(1) - 추가 메모리 불필요
- **비교**: 선형 탐색 O(N) vs 이분 탐색 O(log N)

## 기본 템플릿

### 1. 값 존재 여부 확인
```java
// 정렬된 배열에서 X가 존재하는지 확인
boolean isExist(int[] arr, int X) {
    int l = 0;              // 왼쪽 끝
    int r = arr.length - 1; // 오른쪽 끝
    
    while (l <= r) {        // 탐색 범위가 유효한 동안
        int m = l + (r - l) / 2;  // 중간 인덱스 (오버플로우 방지)
        
        if (arr[m] < X) {
            l = m + 1;      // 오른쪽 절반 탐색
        } else if (arr[m] > X) {
            r = m - 1;      // 왼쪽 절반 탐색
        } else {
            return true;    // 값 찾음
        }
    }
    return false;           // 값 없음
}
```

### 2. Lower Bound (이상인 첫 위치)
```java
// target 이상인 값이 처음 나타나는 위치 (인덱스)
int lowerBound(int[] arr, int target) {
    int left = 0;
    int right = arr.length;  // 주의: length (마지막 인덱스 + 1)
    
    while (left < right) {   // 주의: left < right (= 없음)
        int mid = left + (right - left) / 2;
        
        if (arr[mid] >= target) {  // 이상이면
            right = mid;           // 오른쪽 경계 당김
        } else {
            left = mid + 1;        // 왼쪽 경계 밀어냄
        }
    }
    return left;  // target 이상인 첫 위치
}
```

### 3. Upper Bound (초과하는 첫 위치)
```java
// target을 초과하는 값이 처음 나타나는 위치 (인덱스)
int upperBound(int[] arr, int target) {
    int left = 0;
    int right = arr.length;
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] > target) {  // 초과면
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;  // target 초과하는 첫 위치
}
```

## 주요 변형 패턴

### 1. 개수 세기
```java
// target의 개수 = upperBound - lowerBound
int count = upperBound(arr, target) - lowerBound(arr, target);
// [lowerBound, upperBound) 반열린 구간
```

### 2. 매개변수 탐색 (Parametric Search)
```java
// "조건을 만족하는 최솟값/최댓값" 찾기
// 예: 랜선 자르기, 공유기 설치 등
int parametricSearch(int[] arr, int target) {
    int left = 1;
    int right = 1000000000;  // 충분히 큰 값
    int result = 0;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (isPossible(arr, mid, target)) {  // mid로 조건 만족?
            result = mid;     // 일단 저장
            left = mid + 1;   // 더 큰 값 시도 (최댓값 찾기)
            // right = mid - 1;  // 더 작은 값 시도 (최솟값 찾기)
        } else {
            right = mid - 1;  // 조건 불만족, 범위 줄임
        }
    }
    return result;
}
```

## 실수 포인트 & 디버깅 팁

### 1. 오버플로우 주의
❌ `int mid = (left + right) / 2;`  // left + right가 int 범위 초과 가능   
✅ `int mid = left + (right - left) / 2;`  // 안전

### 2. 무한 루프 조심
**기본 탐색**: `while (l <= r)` + `r = arr.length - 1`
- `l = m + 1`, `r = m - 1` 사용

**Lower/Upper Bound**: `while (l < r)` + `r = arr.length`
- `l = m + 1`, `r = m` 사용
- `=` 없으면 무한 루프!

### 3. 경계 조건 체크
```java
// Lower Bound 결과가 배열 범위 내인지 확인
int idx = lowerBound(arr, target);
if (idx < arr.length && arr[idx] == target) {
    // target이 실제 존재함
}
```

### 4. 정렬 필수!
```java
Arrays.sort(arr);  // 이분 탐색 전 반드시 정렬!
```

## 면접 대비 핵심

**Q1. 이분 탐색의 시간복잡도가 O(log N)인 이유는?**
- 매 단계마다 탐색 범위가 절반씩 줄어들기 때문입니다.
- N개 데이터를 1개로 줄이는데 필요한 횟수 = log₂N
- 예: 1,000,000개 → 약 20번만에 탐색 완료

**Q2. Lower Bound와 Upper Bound의 차이는?**
- Lower Bound: target **이상**인 첫 위치 (arr[i] >= target)
- Upper Bound: target **초과**하는 첫 위치 (arr[i] > target)
- 개수 세기: `upperBound - lowerBound`

**Q3. while 조건이 `l <= r`과 `l < r` 두 가지인 이유는?**
- `l <= r`: 값 존재 여부 확인할 때 (정확한 인덱스 찾기)
- `l < r`: 경계값 찾을 때 (Lower/Upper Bound)
- Lower/Upper는 "칸막이" 개념으로 right를 arr.length로 설정

**Q4. 매개변수 탐색(Parametric Search)이란?**
- "조건을 만족하는 최솟값/최댓값"을 이분 탐색으로 찾는 기법
- 예: 랜선 자르기(최대 길이), 공유기 설치(최대 거리)
- 핵심: 결정 문제로 바꾸기 ("X로 가능한가?" → Yes/No)

**Q5. 이분 탐색을 쓸 수 없는 경우는?**
- 데이터가 정렬되어 있지 않을 때
- 데이터가 배열이 아닌 연결 리스트일 때 (O(1) 접근 불가)
- 탐색 조건이 단조성을 만족하지 않을 때

## 실전 팁
1. **정렬 확인**: 문제에서 "정렬된"이라는 키워드 확인
2. **범위 설정**: left, right 초기값 신중하게 (특히 매개변수 탐색)
3. **조건 분기**: `<`, `>`, `>=` 부등호 정확히 사용
4. **결과 저장**: 조건 만족 시 result에 저장 후 계속 탐색
5. **경계 검사**: 결과 인덱스가 유효한 범위인지 확인
