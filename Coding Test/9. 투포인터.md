## 투포인터
- (주로) 정렬된 선형 데이터 구조에서 **두개의 인덱스(포인터)** 를 관리하여 원하는 값을 찾는 알고리즘
- **사용하는 이유** : 완전 탐색 O(N^2)으로 풀 문제를 투 포인터 O(N)으로 풀면 시간 초과를 방지할 수 있다.
- **핵심 원리** : 한쪽 인덱스를 옮겼을 때, 다른 쪽 인덱스가 반드시 한 방향으로만 움직여야 한다. ( 왔다갔다하면 투포인터가 아님 )

## 슬라이딩 윈도우(Sliding Window)
- **창문의 길이(구간의 길이)가 고정**되어 있는 특수한 형태이다.
- 고정된 크기의 창문을 옆으로 한 칸씩 미는 것과 같다.
- 즉, 투포인터와 달리 right가 한 칸 가면, left도 한 칸 이동을 해야한다.
- **장점** : 구간의 합을 구할 시, 매번 처음부터 끝까지 다 더할 필요 없이 **새로 들어오는 값은 더하고, 빠지는 값은 뺀다.** O(N)으로 가능.
  
## 투포인터 접근 3가지 유형

#### 1. 같은 방향에서 시작 (Sliding Window 포함)
- 연속된 부분 수열의 합이 M이 되는 구간을 찾거나, 조건에 맞는 가장 긴/짧은 구간을 찾을 때 쓴다.
- **작동 방식** : left, right가 모두 0에서 시작해서, 합이 작으면 right를 늘리고 합이 크면 left를 줄인다.
- while문 하나로 처리하지 않고, for문으로 left를 고정하고 내부에서 right를 **최대한 밀어내는 방식**이 코드 관리에 깔끔하다.

```java
public int solveSameDirection(int[] arr, int target) {
    int n = arr.length;
    int sum = 0, right = 0, ans = Integer.MAX_VALUE;

    for (int left = 0; left < n; left++) {
        // 1. right를 조건이 만족할 때까지 전진
        while (right < n && sum < target) {
            sum += arr[right++];
        }
        
        // 2. 조건 만족 시 정답 갱신
        if (sum >= target) {
            ans = Math.min(ans, right - left);
        }
        
        // 3. left를 넘기기 전, 현재 left 값을 윈도우에서 제거
        sum -= arr[left];
    }
    return ans;
}
```

#### 2. 양 끝에서 서로를 향해 시작
- 정렬된 배열에서 두 수의 합이 특정 값에 가까운 쌍을 찾을 때 사용한다.
- **작동 방식** : `left = 0, right = N - 1`에서 시작한다.
- **판단** : `sum > target` 이면 합을 줄여야 하기 때문에, `right--`, `sum < target`이면 합을 키워야 하기 때문에 `left++`
```java
public void solveBothEnds(int[] arr, int target) {
    Arrays.sort(arr); // 반드시 정렬 필요
    int left = 0;
    int right = arr.length - 1;

    while (left < right) {
        int sum = arr[left] + arr[right];

        if (sum == target) {
            // 정답 처리 (예: 출력 후 포인터 둘 다 이동)
            System.out.println(left + " " + right);
            left++; right--;
        } else if (sum < target) {
            left++; // 합이 작으면 왼쪽을 키움
        } else {
            right--; // 합이 크면 오른쪽을 줄임
        }
    }
}
```

#### 3. 서로 다른 두 배열의 비교
- 두 배열을 합치거나 공통 요소를 찾을 때 사용한다.
- **작동 방식** : 배열을 정렬한 후, 각 배열에 포인터를 하나씩 두고 작은 쪽의 포인터를 전진시킨다.
```java
public List<Integer> solveTwoArrays(int[] arr1, int[] arr2) {
    int p1 = 0, p2 = 0;
    List<Integer> result = new ArrayList<>();

    while (p1 < arr1.length && p2 < arr2.length) {
        if (arr1[p1] < arr2[p2]) {
            result.add(arr1[p1++]);
        } else {
            result.add(arr2[p2++]);
        }
    }
    // 남은 요소 처리
    while (p1 < arr1.length) result.add(arr1[p1++]);
    while (p2 < arr2.length) result.add(arr2[p2++]);
    
    return result;
}
```

## 누적합 vs 투포인터
- 배열에 음수가 포함되어 있으면, 투 포인터를 쓸 수 없다. ( 오른쪽을 늘린다고 해서, 합이 커진다는 보장이 없음. )
- 이런 경우는 Map을 활용한 누적합을 쓰는 것이 낫다.
```java
public int solveWithNegative(int[] arr, int target) {
    int count = 0;
    int currentSum = 0;
    Map<Integer, Integer> sumMap = new HashMap<>();
    
    // 0의 누적합이 1번 있었다고 초기화 (중요)
    sumMap.put(0, 1);

    for (int num : arr) {
        currentSum += num;
        
        // (현재 누적합 - 목표값)이 이전에 존재했다면, 그 구간의 합은 target임
        if (sumMap.containsKey(currentSum - target)) {
            count += sumMap.get(currentSum - target);
        }
        
        // 현재 누적합을 Map에 기록
        sumMap.put(currentSum, sumMap.getOrDefault(currentSum, 0) + 1);
    }
    return count;
}
```

## 인덱스 범위 주의
- `right < n` 조건은 항상 while문 앞에 두어야 한다. 인덱스 에러를 방지하기 위해 `right`가 배열 끝에 도착했을 때 예외처리가 필수이다.

## 시간 복잡도 계산
- 얼핏보면 중첩 루프 같지만, `left`, `right`가 각각 최대 N번씩만 움직이기 때문에 최종적으로 O(N)이 된다.

