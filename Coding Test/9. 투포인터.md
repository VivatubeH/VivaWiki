# 투 포인터 (Two Pointers)

## 핵심 개념
- **정의**: 정렬된 선형 자료구조에서 두 개의 인덱스를 관리하여 O(N) 시간에 문제를 해결하는 알고리즘
- **사용 시기**: 완전탐색 O(N²)으로 풀면 시간초과가 나는 배열/리스트 문제
- **핵심 원리**: 한쪽 포인터를 움직이면, 다른 포인터는 **반드시 한 방향으로만** 이동 (왔다갔다 X)
- **시간복잡도**: O(N) - 각 포인터가 최대 N번씩만 이동

## 슬라이딩 윈도우와의 차이
- **슬라이딩 윈도우**: 구간 길이가 **고정**된 투 포인터의 특수형
- right가 1칸 가면 → left도 1칸 이동 (창문을 옆으로 미는 것)
- 매번 전체 구간 합을 다시 계산하지 않고, 새 값은 더하고 빠진 값은 빼기만 하면 됨

## 투 포인터 3가지 유형

### 1. 같은 방향 시작 (Sliding Window 포함)
**사용 케이스**: 연속 부분수열의 합, 조건 만족 최장/최단 구간
```java
public int sameDirection(int[] arr, int target) {
    int n = arr.length;
    int sum = 0, right = 0, ans = Integer.MAX_VALUE;

    for (int left = 0; left < n; left++) {
        // 1. right를 조건 만족까지 전진
        while (right < n && sum < target) {
            sum += arr[right++];
        }
        
        // 2. 조건 만족 시 정답 갱신
        if (sum >= target) {
            ans = Math.min(ans, right - left);
        }
        
        // 3. left 이동 전 현재 값 제거
        sum -= arr[left];
    }
    return ans;
}
```

**핵심 포인트**:
- for문으로 left 고정 → while로 right 최대한 밀기
- sum 계산 후 left 값 제거 필수

### 2. 양 끝에서 시작
**사용 케이스**: 정렬 배열에서 두 수의 합 문제
```java
public void bothEnds(int[] arr, int target) {
    Arrays.sort(arr); // 반드시 정렬 필요!
    int left = 0, right = arr.length - 1;

    while (left < right) {
        int sum = arr[left] + arr[right];

        if (sum == target) {
            // 정답 처리
            left++; right--;
        } else if (sum < target) {
            left++;  // 합 키우기
        } else {
            right--; // 합 줄이기
        }
    }
}
```

**핵심 포인트**:
- 정렬 필수
- sum > target → right--, sum < target → left++

### 3. 서로 다른 두 배열 비교
**사용 케이스**: 두 배열 합치기, 공통 원소 찾기
```java
public List<Integer> twoArrays(int[] arr1, int[] arr2) {
    int p1 = 0, p2 = 0;
    List<Integer> result = new ArrayList<>();

    while (p1 < arr1.length && p2 < arr2.length) {
        if (arr1[p1] < arr2[p2]) {
            result.add(arr1[p1++]);
        } else {
            result.add(arr2[p2++]);
        }
    }
    
    // 남은 요소 처리
    while (p1 < arr1.length) result.add(arr1[p1++]);
    while (p2 < arr2.length) result.add(arr2[p2++]);
    
    return result;
}
```

## 투 포인터를 쓸 수 없는 경우 → 누적합

**문제**: 배열에 **음수**가 있으면 투 포인터 불가
- 이유: right를 늘려도 합이 커진다는 보장이 없음

**해결**: HashMap + 누적합
```java
public int solveWithNegative(int[] arr, int target) {
    int count = 0, currentSum = 0;
    Map<Integer, Integer> sumMap = new HashMap<>();
    
    sumMap.put(0, 1); // 누적합 0이 1번 있었다고 초기화 (중요!)

    for (int num : arr) {
        currentSum += num;
        
        // (현재 누적합 - target)이 이전에 존재 → 그 구간 합 = target
        if (sumMap.containsKey(currentSum - target)) {
            count += sumMap.get(currentSum - target);
        }
        
        sumMap.put(currentSum, sumMap.getOrDefault(currentSum, 0) + 1);
    }
    return count;
}
```

**핵심 포인트**:
- `sumMap.put(0, 1)` 초기화 필수
- `currentSum - target`의 존재 여부로 구간 판단

## 실수하기 쉬운 포인트

1. **인덱스 범위 체크**
   - `while (right < n && ...)` 조건 순서 중요
   - right 먼저 체크해야 배열 범위 초과 방지

2. **left 이동 전 값 제거**
   - `sum -= arr[left]` 빼먹으면 합 계산 오류

3. **정렬 여부 확인**
   - 양 끝 시작 유형은 정렬 필수
   - 같은 방향 시작은 정렬 불필요한 경우 多

4. **음수 배열 판단**
   - 음수 있으면 투 포인터 대신 누적합 고려

## 면접 대비 핵심

**Q1. 투 포인터의 시간복잡도가 O(N)인 이유는?**
- 중첩 루프처럼 보이지만, left와 right가 각각 최대 N번씩만 이동
- 총 이동 횟수 = 2N → O(N)

**Q2. 투 포인터를 쓸 수 없는 경우는?**
- 배열에 음수가 포함된 경우
- 포인터를 늘려도 값이 단조증가/감소하지 않으면 불가능
- 이 경우 HashMap 누적합 사용

**Q3. 슬라이딩 윈도우와 투 포인터의 차이는?**
- 슬라이딩 윈도우: 구간 길이 고정
- 투 포인터: 구간 길이 가변
- 슬라이딩 윈도우는 투 포인터의 특수한 형태

**Q4. 정렬이 필요한 경우와 불필요한 경우는?**
- 필요: 양 끝에서 시작하는 유형, 두 배열 합치기
- 불필요: 같은 방향 시작 유형 (연속 부분수열)

**Q5. 실전에서 투 포인터 적용 판단 기준은?**
- 완전탐색 O(N²)으로 풀면 시간초과 예상
- 한쪽 포인터 이동 시 다른 쪽도 한 방향으로만 이동 가능
- 배열/리스트의 구간 합, 쌍 찾기 문제
