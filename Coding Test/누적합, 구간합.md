## 누적합과 구간합
* **누적합 (Prefix Sum)**: 배열의 시작부터 특정 지점까지의 모든 원소를 더한 값을 미리 계산해 둔 별도의 배열.
* **구간합 (Range Sum)**: 배열의 특정 구간 $[i, j]$에 대한 합.

## 2. 작동 원리와 공식 💡

### [1차원 누적합]
원본 배열을 `A`, 누적합 배열을 `S`라고 할 때:
* **누적합 생성 공식**: $S[i] = S[i-1] + A[i]$
* **구간합 산출 공식**: $A[i]$부터 $A[j]$까지의 합은 **$S[j] - S[i-1]$**

> **⚠️ 주의 (Zero-Padding)**
> 누적합 배열을 만들 때는 인덱스 $0$을 $0$으로 비워두는 **'1-based Indexing'**을 사용하는 것이 권장된다.
> - 예: `S[0] = 0`으로 설정하면, $1$번부터 $j$번까지의 합을 구할 때 `S[j] - S[0]`으로 인덱스 에러 없이 계산 가능하다.
> - **1-based Indexing** : 배열의 첫 원소를 1번 인덱스부터 시작하는 걸로 취급하는 방식, 즉 0번을 더미로 비워두고 N + 1크기의 배열을 생성하는 방식

---

## 3. 성능 비교 (단순 순회 vs 누적합) ⏳

| 작업 | 단순 순회 (Brute Force) | 누적합 (Prefix Sum) |
| :--- | :--- | :--- |
| **전처리 (배열 생성)** | 없음 ($0$) | $O(N)$ |
| **구간합 조회 (Query)** | $O(N)$ | **$O(1)$** |
| **원소 갱신 (Update)** | **$O(1)$** | $O(N)$ |

* **배열 순회 전체 복잡도**: $O(Q \times N + K)$
* **누적합 사용 전체 복잡도**: $O(N + Q + K \times N)$
* **결론**: 데이터 갱신($K$)이 적고, 합계 조회($Q$)가 빈번한 상황에서 압도적으로 유리합니다.

---

## 4. 심화: 2차원 누적합 (2D Prefix Sum) ⭐
2차원 배열(행렬) 내에서 특정 사각형 영역의 합을 구할 때 사용합니다.

### 2차원 누적합 배열 만들기
$(1, 1)$부터 $(i, j)$까지의 합 $S[i][j]$는 다음과 같이 구합니다:

$$S[i][j] = A[i][j] + S[i-1][j] + S[i][j-1] - S[i-1][j-1]$$
**(중복으로 더해진 $(i-1, j-1)$ 영역을 한 번 빼주는 것이 포인트)**

### 2차원 구간합 구하기
$(x1, y1)$부터 $(x2, y2)$까지의 사각형 구간합은:
$$Sum = S[x2][y2] - S[x1-1][y2] - S[x2][y1-1] + S[x1-1][y1-1]$$

### 2차원 누적합과 2차원 구간합 직관적으로 받아들이기
- **2차원 누적합 배열 만들기(전처리)** : **위쪽 합 + 왼쪽 합 - 중복된 대각선 부분 + 현재 칸의 값**
- **2차원 구간합 구하기(조회)**: **전체 큰 사각형 - 위쪽 덩어리 - 왼쪽 덩어리 + 중복 제거한 대각선 부분**
---

## 5. 실전 적용 팁 🚩
1. **사용 타이밍**: 배열의 값이 고정되어 있고, 구간 합 쿼리가 수만 번 이상 들어올 때 필수적으로 사용합니다.
2. **갱신이 잦을 때**: 누적합 배열은 값 하나만 바뀌어도 뒤의 모든 합을 다시 계산해야 하므로 부적합합니다. 
3. **자료형 주의**: $N$이 크고 원소의 값이 크면 누적합의 결과가 `int` 범위를 넘어갈 수 있으므로 `long` 타입을 사용해야 합니다.
