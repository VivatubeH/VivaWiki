# 매개변수 탐색 (Parametric Search)
- **정의**: 이분 탐색(Binary Search)을 활용하여 **최적화 문제(Optimization Problem)** -> **결정 문제(Decision Problem)** 로 전환해서 해결하는 기법
- **핵심 질문**: "최솟값/최댓값이 무엇인가?"라는 질문을 **"이 값(A)이 조건을 만족하는가? (Yes/No)"** 질문으로 바꾸어 탐색 범위를 좁혀 나갑니다.

## 2. 적용 조건

### 결정성 (Decisiveness)
특정 값 $X$를 경계로 조건을 만족하는 집합과 만족하지 않는 집합이 **단조성(Monotonicity)** 을 띠며 확연히 구분되어야 합니다.
- **예**: $A$에서 조건을 만족한다면, $A$보다 작은(혹은 큰) 모든 값에서도 반드시 조건을 만족해야 함.

### 범위 (Range)
탐색하고자 하는 답의 범위가 정해져 있어야 합니다.

## 3. 이분 탐색의 응용: Lower Bound & Upper Bound
매개변수 탐색의 논리는 배열에서 특정 값의 경계를 찾는 `Lower Bound`와 `Upper Bound` 알고리즘에 그대로 적용됩니다.

| 기법 | 조건 식 D(A) | 의미 |
|------|-------------|------|
| **Lower Bound(Target)** | `A >= Target` | Target 이상의 값이 처음 나타나는 위치 탐색 |
| **Upper Bound(Target)** | `A > Target` | Target을 초과하는 값이 처음 나타나는 위치 탐색 |

### 시각적 흐름
```
탐색 범위: [L ............................ R]
                 ↓ 추정값 A 선택 (Mid)
판정 함수: D(A) 실행 (Yes or No?)
                 ↓ 결과에 따라 범위 축소
L 또는 R 이동 -> 반복
```

## 4. 최적해 찾기 프로세스

매개변수 탐색을 적용하는 정석적인 3단계 방법론입니다.

### Step 1: Binary Search

탐색할 답의 범위를 지정하고 중앙값(Mid)을 선택합니다.

### Step 2: Decision Problem (Yes/No)

선택된 중앙값이 문제의 조건을 만족하는지 판정 함수(`Check` 함수)를 통해 확인합니다.

### Step 3: Update Range

- **조건을 만족한다면 (Yes)**: 더 나은 최적해가 있는지 확인하기 위해 범위를 조정합니다.
- **만족하지 않는다면 (No)**: 조건을 만족할 수 있는 범위로 이동합니다.

## 5. 예시 코드 구조 (Java)

매개변수 탐색의 일반적인 코드 템플릿입니다.

# 최댓값 찾기 
```java
long L = min_value; 
long R = max_value;
long result = L;

while (L <= R) {
    long mid = L + (R - L) / 2; // 오버플로우 방지용 계산식

    if (check(mid)) {     // 조건을 만족한다면 (Yes)
        result = mid;     // 일단 답으로 킵!
        L = mid + 1;      // 더 큰 값이 있는지 오른쪽을 더 본다.
    } else {              // 조건을 만족 못 한다면 (No)
        R = mid - 1;      // 너무 멀리 갔다, 왼쪽으로 범위를 좁힌다.
    }
}
return result;
```

# 최솟값 찾기
```java
long L = min_value;
long R = max_value;
long result = R;

while (L <= R) {
    long mid = L + (R - L) / 2;

    if (check(mid)) {     // 조건을 만족한다면 (Yes)
        result = mid;     // 일단 답으로 킵! (시간이 남을 수도 있으니까)
        R = mid - 1;      // 더 줄일 수 있는지 왼쪽을 더 본다.
    } else {              // 조건을 만족 못 한다면 (No)
        L = mid + 1;      // 시간이 부족하다, 오른쪽으로 범위를 늘린다.
    }
}
return result;
```

# 판정함수
```java
/**
 * @param val 검사할 추정값 (예: 나무의 높이, 소요 시간 등)
 * @return 조건을 만족하면 true, 아니면 false (100% 결정적)
 */
private static boolean check(long val) {
    long sum = 0;
    for (int i = 0; i < N; i++) {
        // 문제의 로직에 따라 sum 계산
        // 예: (나무 길이 - val)이 0보다 크면 sum에 더함
        if (arr[i] > val) {
            sum += (arr[i] - val);
        }
    }
    
    // 목표치(target) 이상을 달성했는지 반환
    return sum >= M; 
}
```

## 주요 포인트 정리

| 항목 | 설명 |
|------|------|
| **시간복잡도** | O(log(범위) × 판정함수 시간복잡도) |
| **공간복잡도** | O(1) |
| **장점** | 최적화 문제를 효율적으로 해결 |
| **단점** | 단조성이 보장되지 않으면 사용 불가 |
