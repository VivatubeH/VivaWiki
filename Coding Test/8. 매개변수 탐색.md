# 매개변수 탐색 (Parametric Search)

## 핵심 개념
- **정의**: 이분 탐색을 활용해 최적화 문제를 결정 문제(Yes/No)로 바꿔서 푸는 기법
- **핵심 전환**: "최솟값/최댓값이 뭐야?" → "이 값 A가 조건 만족해? (Yes/No)"
- **언제 쓰나**: 정렬된 배열이 없어도, 답의 범위가 정해져 있고 단조성이 있으면 OK

## 시간/공간 복잡도
- **시간**: `O(log(답의 범위) × 판정함수 복잡도)`
- **공간**: `O(1)` (추가 배열 불필요)

## 적용 조건 (필수 체크!)
1. **단조성**: A에서 조건 만족하면 → A보다 작은(큰) 값도 전부 만족
2. **범위 확정**: 답이 나올 수 있는 최소/최대값이 명확해야 함
3. **판정 가능**: 특정 값이 조건 만족하는지 빠르게 확인 가능해야 함

## 표준 코드 템플릿

### 1. 최댓값 찾기 (공유기 설치, 나무 자르기 등)
```java
long L = 최소값;          // 답이 될 수 있는 최소 범위
long R = 최대값;          // 답이 될 수 있는 최대 범위
long result = L;         // 최악의 경우 대비 초기값

while (L <= R) {
    long mid = L + (R - L) / 2;  // ⚠️ (L+R)/2는 오버플로우 위험!
    
    if (check(mid)) {     // mid로 조건 만족? (Yes)
        result = mid;     // ✅ 일단 답 저장 (더 큰 값 있을 수도)
        L = mid + 1;      // 더 큰 값도 가능한지 오른쪽 탐색
    } else {              // mid로 조건 불만족 (No)
        R = mid - 1;      // 너무 크다, 왼쪽으로 범위 축소
    }
}
return result;
```

### 2. 최솟값 찾기 (시간, 비용 등)
```java
long L = 최소값;
long R = 최대값;
long result = R;         // 최악의 경우 대비 초기값

while (L <= R) {
    long mid = L + (R - L) / 2;
    
    if (check(mid)) {     // mid로 조건 만족? (Yes)
        result = mid;     // ✅ 일단 답 저장 (더 작은 값 있을 수도)
        R = mid - 1;      // 더 줄일 수 있는지 왼쪽 탐색
    } else {              // mid로 조건 불만족 (No)
        L = mid + 1;      // 너무 작다, 오른쪽으로 범위 확대
    }
}
return result;
```

### 3. 판정 함수 (Check)
```java
/**
 * @param mid 검사할 추정값
 * @return 조건 만족 여부 (true/false)
 */
private static boolean check(long mid) {
    long count = 0;  // 또는 sum, 문제에 따라 다름
    
    // 예시: 나무 자르기 문제
    for (int i = 0; i < N; i++) {
        if (arr[i] > mid) {  // mid 높이로 잘랐을 때
            count += (arr[i] - mid);  // 얻는 나무 길이
        }
    }
    
    return count >= M;  // 목표량 이상 확보했는지 판정
}
```

## 주요 변형 패턴

### Lower Bound (Target 이상 첫 위치)
```java
int L = 0, R = arr.length - 1;
int result = arr.length;  // 못 찾으면 끝 인덱스

while (L <= R) {
    int mid = L + (R - L) / 2;
    if (arr[mid] >= target) {  // ✅ 조건: 타겟 이상
        result = mid;
        R = mid - 1;  // 더 왼쪽에 있을 수도
    } else {
        L = mid + 1;
    }
}
```

### Upper Bound (Target 초과 첫 위치)
```java
int L = 0, R = arr.length - 1;
int result = arr.length;

while (L <= R) {
    int mid = L + (R - L) / 2;
    if (arr[mid] > target) {  // ✅ 조건: 타겟 초과
        result = mid;
        R = mid - 1;
    } else {
        L = mid + 1;
    }
}
```

## 실수 포인트 & 디버깅 팁

### ⚠️ 자주 하는 실수
1. **오버플로우**: `(L + R) / 2` 대신 `L + (R - L) / 2` 사용 필수!
2. **초기값 설정 실수**: 
   - 최댓값 찾기 → `result = L` (최소값으로 초기화)
   - 최솟값 찾기 → `result = R` (최대값으로 초기화)
3. **check 함수 부등호 반대**: 
   - 최댓값: `check(mid) == true`면 더 큰 값 탐색
   - 최솟값: `check(mid) == true`면 더 작은 값 탐색
4. **while 조건**: `L <= R` 빼먹지 말기 (등호 필수!)

### 디버깅 체크리스트
```java
// 1. 범위 설정 확인
System.out.println("L: " + L + ", R: " + R);

// 2. mid 값 확인
System.out.println("mid: " + mid + ", check(mid): " + check(mid));

// 3. result 갱신 확인
if (check(mid)) {
    System.out.println("✅ 조건 만족 → result: " + mid);
}
```

### 문제 유형별 패턴
| 문제 유형 | L (최소) | R (최대) | check 함수 의미 |
|----------|---------|---------|---------------|
| 나무 자르기 | 0 | max(나무길이) | mid 높이로 잘라서 M 이상 확보? |
| 공유기 설치 | 1 | max(집위치) - min(집위치) | mid 간격으로 C개 설치 가능? |
| 랜선 자르기 | 1 | max(랜선길이) | mid 길이로 잘라서 N개 이상? |
| 시간 최소화 | 1 | max(시간) × N | mid 시간으로 N개 처리 가능? |

## 면접 대비 핵심

**Q1. 매개변수 탐색과 일반 이분 탐색의 차이는?**
- 일반 이분 탐색: 정렬된 배열에서 특정 값 찾기 (값이 실제로 존재)
- 매개변수 탐색: 조건을 만족하는 최적값 찾기 (값이 가상, 범위 내 탐색)
- 예: 배열에 5가 없어도 "5 이상 첫 값"은 찾을 수 있음

**Q2. check 함수의 시간복잡도가 중요한 이유는?**
- 매개변수 탐색은 `O(log N) × check 함수` 복잡도
- check가 O(N)이면 전체 O(N log N), O(N²)이면 O(N² log N)
- 따라서 check 함수 최적화가 핵심!

**Q3. 단조성이 없으면 절대 못 쓰나?**
- 네, 단조성 없으면 매개변수 탐색 불가능
- 예: A=5에서 조건 만족, A=10에서 불만족, A=15에서 다시 만족 → 이분 탐색 불가
- 이럴 땐 완전 탐색이나 DP 등 다른 알고리즘 고려

**Q4. result 초기값을 왜 L 또는 R로 설정하나?**
- 최댓값 찾기: `result = L` → 최악의 경우 최소값이 답
- 최솟값 찾기: `result = R` → 최악의 경우 최대값이 답
- 조건 만족하는 값이 없으면 초기값 그대로 리턴

**Q5. 실전에서 가장 헷갈리는 부분은?**
- **check 함수 후 L/R 이동 방향**
  - 최댓값: true면 `L = mid + 1` (더 큰 값 찾기)
  - 최솟값: true면 `R = mid - 1` (더 작은 값 찾기)
- 외우지 말고 "조건 만족하면 더 좋은 답 있는 방향으로" 이해하기!
