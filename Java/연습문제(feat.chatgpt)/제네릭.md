```java
// 문제 1: 제네릭 클래스를 작성하시오.
// 클래스 이름은 `Box`로 하고, 타입 파라미터는 `T`로 지정합니다.
// `T` 타입의 변수를 하나 선언하고, `T` 타입을 반환하는 메서드 `getValue()`를 작성하세요.
public class Box<T> {
    // 여기에 코드를 작성하세요
}
```

```java
// 문제 2: 위에서 작성한 `Box` 클래스를 이용하여, `String` 타입을 담을 수 있는 `Box` 객체를 생성하세요.
// 또한, `Integer` 타입을 담을 수 있는 `Box` 객체도 생성하고, 각 객체에 값을 저장한 후 출력해보세요.
public class Main {
    public static void main(String[] args) {
        // 여기에 코드를 작성하세요
    }
}
```

```java
// 문제 3: 제네릭 메서드를 작성하시오.
// 메서드 이름은 `printValue`이고, 타입 파라미터는 `T`로 지정합니다.
// 이 메서드는 `T` 타입의 값을 받아 출력한 뒤, 그 값을 반환하는 메서드입니다.
public class GenericMethodExample {
    // 여기에 코드를 작성하세요
}
```

```java
// 문제 4: 위에서 작성한 `printValue` 메서드를 `Integer`와 `String` 타입에 대해 호출하세요.
// `Integer`와 `String` 타입을 매개변수로 전달하고, 그 결과를 출력해보세요.
public class Main {
    public static void main(String[] args) {
        // 여기에 코드를 작성하세요
    }
}
```

```java
// 문제 5: 타입 매개변수 `T`가 `Number` 클래스 또는 그 하위 클래스만 받을 수 있도록 제한하는 제네릭 클래스를 작성하세요.
// 이 클래스는 `T` 타입을 담고, `T` 타입의 값을 반환하는 `getValue()` 메서드를 작성하세요.
public class NumberBox<T extends Number> {
    // 여기에 코드를 작성하세요
}
```

```java
// 문제 6: 위에서 작성한 `NumberBox` 클래스를 사용하여 `Integer`와 `Double` 타입의 객체를 생성하고, 값을 저장하고 출력해보세요.
// `String` 타입을 넣으려고 하면 컴파일 오류가 발생해야 합니다.
public class Main {
    public static void main(String[] args) {
        // 여기에 코드를 작성하세요
    }
}
```

```java
// 문제 7: 와일드카드를 사용하여 `BioUnit`을 상속받은 타입만 받을 수 있도록 제네릭 메서드를 작성하세요.
// `? extends BioUnit`을 사용하여 `BioUnit` 클래스와 그 자식 클래스들을 모두 처리할 수 있도록 합니다.
// 메서드는 `BioUnit`을 상속받은 객체의 이름을 출력하는 기능을 작성합니다.
public class WildcardExample {
    public static void printUnitName(Shuttle<? extends BioUnit> shuttle) {
        // 여기에 코드를 작성하세요
    }
}
```

```java
// 문제 8: `Shuttle` 클래스를 작성하고, `T extends BioUnit`을 사용하는 제네릭 클래스를 작성하되,
// 와일드카드 `? extends BioUnit`을 사용하여 **`BioUnit`의 자식 클래스들**만 받을 수 있는 메서드를 추가하세요.
// 제네릭 타입의 `T`가 `Dog` 또는 `Cat`일 수 있습니다. `printUnitName` 메서드를 사용하여 그 이름을 출력하세요.
public class Shuttle<T extends BioUnit> {
    // 여기에 코드를 작성하세요
}
```

```java
// 문제 9: 와일드카드를 사용하는 제네릭 메서드를 작성하시오.
// 메서드는 `Shuttle<? extends BioUnit>`을 받으며, 그 안에 들어있는 객체의 이름을 출력합니다.
// 이 메서드를 사용하여 `Shuttle<Dog>` 또는 `Shuttle<Cat>` 객체를 전달하고, 각각의 이름을 출력하세요.
public class WildcardAndGenericMethodExample {
    public static void printName(Shuttle<? extends BioUnit> shuttle) {
        // 여기에 코드를 작성하세요
    }
}
```

```java
// 문제 10: 제네릭 클래스에서 타입 파라미터와 와일드카드를 혼합하여 사용하는 예제를 작성하시오.
// `Shuttle` 클래스는 제네릭을 사용하고, `out` 메서드는 와일드카드를 사용하여 `? extends BioUnit` 타입을 반환합니다.
// `Shuttle` 클래스의 객체를 생성하여 `out` 메서드를 호출하고, 그 결과를 출력하세요.
public class Shuttle<T> {
    public T out() {
        // 여기에 코드를 작성하세요
    }
}
```

<hr/>

```java
// 문제 1번
package generic.chatgpt;

public class Box<T> { // 클래스 이름을 Box, 타입 파라미터는 T로 지정합니다.

    private T t; // 타입 파라미터 T를 저장하기 위한 변수 t를 선언합니다.

    public T getValue() { // 타입 파라미터 T를 반환하는 메서드 getValue() 입니다.
        return t;
    }

    public void setValue(T value) {
        t = value;
    }
}
```

```java
// 문제 2번
package generic.chatgpt;

public class BoxMain {
    public static void main(String[] args) {
        // String 타입을 담을 수 있는 Box 객체 생성
        Box<String> string = new Box<>(); // 제네릭의 타입 추론을 이용했습니다.
        Box<Integer> integer = new Box<Integer>(); // 타입 추론을 안 쓰고 그냥 명시했습니다.

        string.setValue("안녕하세요"); // Box<String>에 String 타입을 담았습니다.
        integer.setValue(11); // Box<Integer>에 Integer 타입을 담았습니다. (기본형의 오토 박싱을 이용했습니다.)

        System.out.println(string.getValue());
        System.out.println(integer.getValue());
    }
}
```

```java

```
