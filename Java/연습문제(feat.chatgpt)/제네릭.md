```java
// 문제 1: 제네릭 클래스를 작성하시오.
// 클래스 이름은 `Box`로 하고, 타입 파라미터는 `T`로 지정합니다.
// `T` 타입의 변수를 하나 선언하고, `T` 타입을 반환하는 메서드 `getValue()`를 작성하세요.
public class Box<T> {
    // 여기에 코드를 작성하세요
}
```

```java
// 문제 2: 위에서 작성한 `Box` 클래스를 이용하여, `String` 타입을 담을 수 있는 `Box` 객체를 생성하세요.
// 또한, `Integer` 타입을 담을 수 있는 `Box` 객체도 생성하고, 각 객체에 값을 저장한 후 출력해보세요.
public class Main {
    public static void main(String[] args) {
        // 여기에 코드를 작성하세요
    }
}
```

```java
// 문제 3: 제네릭 메서드를 작성하시오.
// 메서드 이름은 `printValue`이고, 타입 파라미터는 `T`로 지정합니다.
// 이 메서드는 `T` 타입의 값을 받아 출력한 뒤, 그 값을 반환하는 메서드입니다.
public class GenericMethodExample {
    // 여기에 코드를 작성하세요
}
```

```java
// 문제 4: 위에서 작성한 `printValue` 메서드를 `Integer`와 `String` 타입에 대해 호출하세요.
// `Integer`와 `String` 타입을 매개변수로 전달하고, 그 결과를 출력해보세요.
public class Main {
    public static void main(String[] args) {
        // 여기에 코드를 작성하세요
    }
}
```

```java
// 문제 5: 타입 매개변수 `T`가 `Number` 클래스 또는 그 하위 클래스만 받을 수 있도록 제한하는 제네릭 클래스를 작성하세요.
// 이 클래스는 `T` 타입을 담고, `T` 타입의 값을 반환하는 `getValue()` 메서드를 작성하세요.
public class NumberBox<T extends Number> {
    // 여기에 코드를 작성하세요
}
```

```java
// 문제 6: 위에서 작성한 `NumberBox` 클래스를 사용하여 `Integer`와 `Double` 타입의 객체를 생성하고, 값을 저장하고 출력해보세요.
// `String` 타입을 넣으려고 하면 컴파일 오류가 발생해야 합니다.
public class Main {
    public static void main(String[] args) {
        // 여기에 코드를 작성하세요
    }
}
```

```java
// 문제 7: 와일드카드를 사용하여 `BioUnit`을 상속받은 타입만 받을 수 있도록 제네릭 메서드를 작성하세요.
// `? extends BioUnit`을 사용하여 `BioUnit` 클래스와 그 자식 클래스들을 모두 처리할 수 있도록 합니다.
// 메서드는 `BioUnit`을 상속받은 객체의 이름을 출력하는 기능을 작성합니다.
public class WildcardExample {
    public static void printUnitName(Shuttle<? extends BioUnit> shuttle) {
        // 여기에 코드를 작성하세요
    }
}
```

```java
// 문제 8: 
// 1. `Shuttle` 클래스를 작성하세요.
// 2. `T extends BioUnit`을 사용하는 제네릭 클래스를 작성하세요.
// 3. `T`는 `BioUnit`을 상속한 타입만 받을 수 있어야 합니다. 
// 4. `Shuttle` 클래스 내부에 `T` 타입의 객체를 저장하는 메서드를 작성하세요. 
// 5. 그 후, `? extends BioUnit` 와일드카드를 사용하는 메서드를 작성하세요. 
//    - 이 메서드는 `Shuttle` 객체를 받아서 `BioUnit`의 자식 클래스들의 **이름**을 출력하는 기능을 구현하세요.
//    - 메서드 호출 시 `Dog` 또는 `Cat` 객체를 전달하고, 각각의 이름을 출력하세요.
```

```java
// 문제 9:
// 1. `Shuttle<? extends BioUnit>`을 받는 제네릭 메서드를 작성하세요.
// 2. 이 메서드는 `Shuttle` 객체를 매개변수로 받아, 그 안에 들어 있는 객체의 **이름**을 출력하는 기능을 구현하세요.
// 3. 이 메서드를 사용하여 `Shuttle<Dog>` 또는 `Shuttle<Cat>` 객체를 전달하고, 각각의 이름을 출력하세요.
// 4. `Dog` 또는 `Cat`은 `BioUnit`을 상속한 자식 클래스입니다.
```

```java
// 문제 10:
// 1. `Shuttle` 클래스를 제네릭을 사용하여 작성하세요.
// 2. `T` 타입 파라미터를 사용하는 `Shuttle` 클래스를 작성하세요.
// 3. `Shuttle` 클래스 내부에 `out` 메서드를 작성하세요.
//    - 이 메서드는 `? extends BioUnit` 와일드카드를 사용하여 `BioUnit`을 상속한 자식 클래스들의 객체를 반환하는 방식으로 작성하세요.
// 4. `Shuttle` 클래스의 객체를 생성하여 `out` 메서드를 호출하고, 그 결과를 출력하세요.
```

<hr/>

```java
// 문제 1번
package generic.chatgpt;

public class Box<T> { // 클래스 이름을 Box, 타입 파라미터는 T로 지정합니다.

    private T t; // 타입 파라미터 T를 저장하기 위한 변수 t를 선언합니다.

    public T getValue() { // 타입 파라미터 T를 반환하는 메서드 getValue() 입니다.
        return t;
    }

    public void setValue(T value) {
        t = value;
    }
}
```

```java
// 문제 2번
package generic.chatgpt;

public class BoxMain {
    public static void main(String[] args) {
        // String 타입을 담을 수 있는 Box 객체 생성
        Box<String> string = new Box<>(); // 제네릭의 타입 추론을 이용했습니다.
        Box<Integer> integer = new Box<Integer>(); // 타입 추론을 안 쓰고 그냥 명시했습니다.

        string.setValue("안녕하세요"); // Box<String>에 String 타입을 담았습니다.
        integer.setValue(11); // Box<Integer>에 Integer 타입을 담았습니다. (기본형의 오토 박싱을 이용했습니다.)

        System.out.println(string.getValue());
        System.out.println(integer.getValue());
    }
}
```

```java
// 문제 3번
package generic.chatgpt;

public class GenericMethodExample {

    public <T> T printValue(T t) {
        System.out.println(t);
        return t;
    }
}
```

```java
// 문제 4번
package generic.chatgpt;

public class PrintMain {
    public static void main(String[] args) {
        GenericMethodExample example = new GenericMethodExample();
        example.printValue(new String("비바튜브입니다."));
        example.printValue(Integer.valueOf(10));

        example.<String>printValue(new String("타입을 명시하는 메서드 호출입니다."));
        example.<Integer>printValue(Integer.valueOf(17));
    }
}
```

```java
// 문제 5번
package generic.chatgpt;

public class NumberBox<T extends Number> {
    // 타입 매개변수 T가 Number나 그 하위 클래스만 받을 수 있도록 제한하는 제네릭 클래스입니다.
    private T t; // T타입을 담습니다.

    public T getValue() {
        return t;
    }

    public void setValue(T t) {
        this.t = t;
    }
}
```

```java
// 문제 6번
package generic.chatgpt;

public class NumberBoxMain {
    public static void main(String[] args) {
        NumberBox<Integer> integer = new NumberBox<>(); // 타입 추론 활용
        NumberBox<Double> ddouble = new NumberBox<Double>(); // 타입 명시
        NumberBox<Number> number = new NumberBox<>(); // 같은 타입은 가능
//        NumberBox<String> string1 = new NumberBox<String>(); // 타입 오류로 안 담김
//        NumberBox<String> string2 = new NumberBox<>(); // 타입 추론이든 뭐든 안 담김
    }
}
```

```java
// 문제 7번
package generic.chatgpt;

import generic.test.ex3.unit.*;

class WildCardExample {
    public static void printUnitName(Shuttle<? extends BioUnit> shuttle) {
        System.out.println(shuttle.getClass().getName());
    }
}

class Main {
    public static void main(String[] args) {
        Shuttle<Marine> marine = new Shuttle<>();
        Shuttle<Zealot> zealot = new Shuttle<>();
        Shuttle<Zergling> zergling = new Shuttle<>();

        WildCardExample.printUnitName(marine);
        WildCardExample.printUnitName(zealot);
        WildCardExample.printUnitName(zergling);
    }
}
```

![image](https://github.com/user-attachments/assets/48e7e25a-dc91-4b73-9e17-6b55a573ebbd)

- 위 사진을 보면, 클래스 이름이 모두 Shuttle로 나오게 됩니다.
- 이는 제네릭 타입이 컴파일 시점에 소거되었고, 런타임에는 Shuttle이라는 클래스의 이름만 남기 때문입니다.
- 이러한 타입 소거로 인해, 제네릭 클래스는 실제로는 같은 클래스로 취급됩니다.

```java

```
