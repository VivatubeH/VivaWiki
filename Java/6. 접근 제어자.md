## 핵심 요약
- 접근 제어자(private, default, protected, public)는 클래스 외부에서 필드/메서드 접근을 제한하는 키워드다
- private으로 데이터를 숨기고 public 메서드로만 접근하게 하면 잘못된 값 입력을 원천 차단할 수 있다
- 캡슐화 = 데이터는 전부 숨기고(private), 꼭 필요한 기능만 외부에 공개(public)하는 설계 원칙
- 클래스 레벨에서는 public과 default만 사용 가능하며, public 클래스명은 파일명과 동일해야 한다

# 접근 제어자

## 접근 제어자가 필요한 이유

스피커 음량이 100을 넘으면 부품이 고장난다는 요구사항이 있다고 가정하자.
```java
public class Speaker {
    int volume;

    Speaker(int volume) {
        this.volume = volume;
    }

    void volumeUp() {
        if (volume >= 100) {
            System.out.println("음량을 증가할 수 없습니다. 최대 음량입니다.");
        } else {
            volume += 10;
            System.out.println("음량을 10 증가합니다.");
        }
    }

    void showVolume() {
        System.out.println("현재 음량:" + volume);
    }
}
```

이 코드의 문제점: 외부에서 `speaker.volume = 200` 같은 방식으로 필드에 직접 접근하면 검증 로직을 우회할 수 있다.
```java
Speaker speaker = new Speaker(90);
speaker.volumeUp();  // 정상 동작, 100까지만 증가
speaker.volume = 200;  // 문제 발생! 검증 없이 직접 수정
```

## 해결 방법: private 접근 제어자
```java
public class Speaker {
    private int volume;  // private 키워드 추가

    Speaker(int volume) {
        this.volume = volume;
    }

    void volumeUp() {
        if (volume >= 100) {
            System.out.println("음량을 증가할 수 없습니다. 최대 음량입니다.");
        } else {
            volume += 10;
        }
    }

    void showVolume() {
        System.out.println("현재 음량:" + volume);
    }
}
```

이제 `speaker.volume = 200`을 시도하면 컴파일 에러가 발생한다.
```
volume has private access in access.Speaker
```

외부에서는 오직 `volumeUp()`, `showVolume()` 메서드를 통해서만 volume에 접근 가능하다.

## 접근 제어자 종류

자바는 4가지 접근 제어자를 제공한다.

| 접근 제어자 | 접근 범위 |
|----------|---------|
| private | 같은 클래스 내부에서만 접근 가능 |
| default (package-private) | 같은 패키지 내에서만 접근 가능 |
| protected | 같은 패키지 + 상속 관계에서 접근 가능 |
| public | 모든 곳에서 접근 가능 |

제한 강도: `private` > `default` > `protected` > `public`

### default 접근 제어자

접근 제어자를 명시하지 않으면 default가 적용된다. default는 같은 패키지 내에서만 접근 가능하므로 실제로는 package-private이 더 정확한 표현이다.

## 필드와 메서드 레벨 접근 제어자
```java
package access.a;

public class AccessData {
    public int publicField;
    int defaultField;
    private int privateField;

    public void publicMethod() {
        System.out.println("publicMethod 호출 " + publicField);
    }

    void defaultMethod() {
        System.out.println("defaultMethod 호출 " + defaultField);
    }

    private void privateMethod() {
        System.out.println("privateMethod 호출 " + privateField);
    }

    public void innerAccess() {
        System.out.println("내부 호출");
        publicField = 100;
        defaultField = 200;
        privateField = 300;  // 내부에서는 private도 접근 가능
        publicMethod();
        defaultMethod();
        privateMethod();
    }
}
```

### 같은 패키지에서 접근
```java
package access.a;

public class AccessInnerMain {
    public static void main(String[] args) {
        AccessData data = new AccessData();

        // public 접근 가능
        data.publicField = 1;
        data.publicMethod();

        // 같은 패키지 default 접근 가능
        data.defaultField = 2;
        data.defaultMethod();

        // private 접근 불가
        // data.privateField = 3;  // 컴파일 에러
        // data.privateMethod();   // 컴파일 에러

        data.innerAccess();  // public 메서드는 호출 가능, 내부에서 private 접근
    }
}
```

### 다른 패키지에서 접근
```java
package access.b;

import access.a.AccessData;

public class AccessOuterMain {
    public static void main(String[] args) {
        AccessData data = new AccessData();

        // public 접근 가능
        data.publicField = 1;
        data.publicMethod();

        // 다른 패키지 default 접근 불가
        // data.defaultField = 2;  // 컴파일 에러
        // data.defaultMethod();   // 컴파일 에러

        // private 접근 불가
        // data.privateField = 3;  // 컴파일 에러
        // data.privateMethod();   // 컴파일 에러

        data.innerAccess();  // public 메서드는 호출 가능
    }
}
```

## 클래스 레벨 접근 제어자

클래스에는 `public`과 `default`만 사용 가능하다.

- `public` 클래스는 파일명과 이름이 반드시 같아야 한다
- 하나의 자바 파일에 `public` 클래스는 1개만 존재 가능
- `default` 클래스는 여러 개 존재 가능
```java
package access.a;

// 파일명: PublicClass.java
public class PublicClass {
    public static void main(String[] args) {
        PublicClass publicClass = new PublicClass();
        DefaultClass1 class1 = new DefaultClass1();
        DefaultClass2 class2 = new DefaultClass2();
    }
}

class DefaultClass1 {
}

class DefaultClass2 {
}
```

### 같은 패키지에서 접근
```java
package access.a;

public class PublicClassInnerMain {
    public static void main(String[] args) {
        PublicClass publicClass = new PublicClass();  // public 접근 가능
        DefaultClass1 class1 = new DefaultClass1();  // 같은 패키지 default 접근 가능
        DefaultClass2 class2 = new DefaultClass2();  // 같은 패키지 default 접근 가능
    }
}
```

### 다른 패키지에서 접근
```java
package access.b;

import access.a.PublicClass;
// import access.a.DefaultClass1;  // 컴파일 에러

public class PublicClassOuterMain {
    public static void main(String[] args) {
        PublicClass publicClass = new PublicClass();  // public 접근 가능

        // 다른 패키지 default 접근 불가
        // DefaultClass1 class1 = new DefaultClass1();  // 컴파일 에러
        // DefaultClass2 class2 = new DefaultClass2();  // 컴파일 에러
    }
}
```

## 캡슐화

캡슐화는 데이터와 그 데이터를 처리하는 메서드를 하나로 묶고, 외부에 꼭 필요한 기능만 노출하고 나머지는 모두 숨기는 것이다.

### 캡슐화 원칙

1. **데이터를 숨겨라**
   - 객체의 속성(필드)은 `private`으로 선언
   - 외부에서 필드에 직접 접근하지 못하게 차단
   - 메서드를 통해서만 데이터에 접근하도록 강제

2. **기능을 숨겨라**
   - 외부에서 사용하지 않는 내부 전용 메서드는 `private`으로 선언
   - 외부에 공개할 메서드만 `public`으로 선언

### 캡슐화 예제: 은행 계좌
```java
public class BankAccount {
    private int balance;  // 데이터는 private으로 숨김

    public BankAccount() {
        balance = 0;
    }

    // public 메서드로만 데이터 접근 허용
    public void deposit(int amount) {
        if (isAmountValid(amount)) {
            balance += amount;
        } else {
            System.out.println("유효하지 않은 금액입니다.");
        }
    }

    public void withdraw(int amount) {
        if (isAmountValid(amount) && balance - amount >= 0) {
            balance -= amount;
        } else {
            System.out.println("유효하지 않은 금액이거나 잔액이 부족합니다.");
        }
    }

    public int getBalance() {
        return balance;
    }

    // 내부 검증 로직은 private으로 숨김
    private boolean isAmountValid(int amount) {
        return amount > 0;
    }
}
```

사용 예시:
```java
public class BankAccountMain {
    public static void main(String[] args) {
        BankAccount account = new BankAccount();
        account.deposit(10000);
        account.withdraw(3000);
        System.out.println("balance = " + account.getBalance());
    }
}
```

외부에서는 `deposit()`, `withdraw()`, `getBalance()` 3가지 메서드만 알면 된다. `balance` 필드나 `isAmountValid()` 메서드는 외부에서 알 필요가 없다.

만약 `balance`를 public으로 공개하면:
- 외부에서 `account.balance = 1000000` 같은 직접 수정이 가능해진다
- 모든 검증 로직이 무력화된다
- 데이터 무결성이 깨진다

만약 `isAmountValid()`를 public으로 공개하면:
- 외부 개발자가 "입금/출금 전에 내가 먼저 검증해야 하나?"라고 혼란스러워한다
- API 사용 복잡도가 증가한다

## 연습 문제

### 문제 1: 최대 카운터

최대값까지만 증가하는 카운터 클래스를 만들어라.

요구사항:
- `int count`: 현재 카운트 (초기값 0, private)
- `int max`: 최대값 (생성자로 입력, private)
- `increment()`: 카운트 증가 (최대값 초과 시 메시지 출력)
- `getCount()`: 현재 카운트 반환
- 다른 패키지에서도 사용 가능해야 함
```java
public class CounterMain {
    public static void main(String[] args) {
        MaxCounter counter = new MaxCounter(3);
        counter.increment();
        counter.increment();
        counter.increment();
        counter.increment();
        int count = counter.getCount();
        System.out.println(count);
    }
}
```

실행 결과:
```
최대값을 초과할 수 없습니다.
3
```

정답:
```java
public class MaxCounter {
    private int count = 0;
    private int max;

    public MaxCounter(int max) {
        this.max = max;
    }

    public void increment() {
        if (count >= max) {
            System.out.println("최대값을 초과할 수 없습니다.");
            return;
        }
        count++;
    }

    public int getCount() {
        return count;
    }
}
```

### 문제 2: 쇼핑 카트

요구사항:
- 장바구니에 상품 최대 10개까지만 담을 수 있음
- 접근 제어자로 데이터 캡슐화
- 다른 패키지에서도 사용 가능
```java
public class ShoppingCartMain {
    public static void main(String[] args) {
        ShoppingCart cart = new ShoppingCart();
        Item item1 = new Item("마늘", 2000, 2);
        Item item2 = new Item("상추", 3000, 4);

        cart.addItem(item1);
        cart.addItem(item2);
        cart.displayItems();
    }
}
```

실행 결과:
```
장바구니 상품 출력
상품명:마늘, 합계:4000
상품명:상추, 합계:12000
전체 가격 합:16000
```

정답:
```java
public class Item {
    private String name;
    private int price;
    private int quantity;

    public Item(String name, int price, int quantity) {
        this.name = name;
        this.price = price;
        this.quantity = quantity;
    }

    public String getName() {
        return name;
    }

    public int getTotalPrice() {
        return price * quantity;
    }
}
```
```java
public class ShoppingCart {
    private Item[] items = new Item[10];
    private int itemCount;

    public void addItem(Item item) {
        if (itemCount >= items.length) {
            System.out.println("장바구니가 가득 찼습니다.");
            return;
        }
        items[itemCount] = item;
        itemCount++;
    }

    public void displayItems() {
        System.out.println("장바구니 상품 출력");
        for (int i = 0; i < itemCount; i++) {
            Item item = items[i];
            System.out.println("상품명:" + item.getName() + ", 합계:" + item.getTotalPrice());
        }
        System.out.println("전체 가격 합:" + calculateTotalPrice());
    }

    private int calculateTotalPrice() {
        int totalPrice = 0;
        for (int i = 0; i < itemCount; i++) {
            Item item = items[i];
            totalPrice += item.getTotalPrice();
        }
        return totalPrice;
    }
}
```

핵심:
- `Item.getTotalPrice()`: 자신이 가진 데이터(price, quantity)를 사용해서 계산
- `ShoppingCart.calculateTotalPrice()`: 내부에서만 사용하므로 private
- `items`, `itemCount`, `price`, `quantity` 같은 데이터는 모두 private으로 보호
