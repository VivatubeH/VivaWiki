LinkedList
-----------------------------------
- 낭비되는 메모리 없이, 필요한만큼 메모리를 확보해서 사용하고 데이터의 추가 및 삭제등에도 효율적인 자료 구조가 바로 연결리스트입니다.
- 연결리스트는 노드를 만든 뒤 각 노드들을 서로 연결하는 방식으로 이루어집니다.

```java
public class Node {
  Object item; // 내부에 저장할 데이터인 item
  Node next;  // 다음으로 연결할 노드를 참조하는 next
}
```
- 노드는 내부에 저장할 데이터와 다음으로 연결할 노드에 대한 참조로 이루어진다고 생각하시면 됩니다.

![image](https://github.com/user-attachments/assets/e0e9ec50-5156-4844-a520-7b64a8dc3afc)

- LinkedList는 기본적으로 위와 같이 연결이 됩니다.

```java
Node x = first;
while (x != null) { // 다음 번 노드가 있는 동안 수행됩니다.
  System.out.println(x.item);
  x = x.next; // 다음 번 노드를 가리킵니다.
}
```
- 코드로 보면 위와 같은 방식으로 모든 노드를 탐색하게 됩니다.

연결 리스트 내부 구조 정리
--------------------------------
- 연결리스트의 노드는 내부에 데이터와 데이터에 대한 참조를 동시에 가지고 있습니다.
- 이러한 노드들은 참조를 통해 연결(Link)되어 있습니다.
- 데이터를 추가할 때는 동적으로 필요한 만큼의 노드 생성 -> 연결의 과정을 거치면 되어서 메모리 낭비가 적습니다.

배열리스트와 연결리스트
------------------------------------
- 배열리스트는 내부에서 배열을 사용합니다.
- 연결리스트는 내부에서 노드와 연결 구조를 사용합니다.

배열리스트의 성능
-----------------------------------------
- 특정 위치에 있는 데이터를 반환하는 get 메서드 : 다음 노드를 반복해서 찾아야 하므로 O(n)의 시간 복잡도를 갖습니다.
- 마지막에 데이터를 추가하는 add 메서드 : 시작 위치부터 찾아서 가야하므로 O(n)의 시간 복잡도를 갖습니다.
- 특정 위치에 있는 데이터를 찾아서 변경하는 set 메서드 : 마찬가지로 특정 노드를 찾는데 O(n)의 시간 복잡도를 갖습니다.
- 데이터를 검색하고 위치를 반환하는 indexOf 메서드 : 모든 노드 순회가 필요하므로 O(n)의 시간 복잡도를 갖습니다.

연결리스트의 성능
------------------------------------------

![image](https://github.com/user-attachments/assets/81c8ce35-5c63-40dd-bef6-8f3a2ac10084)
![image](https://github.com/user-attachments/assets/e288d5be-fab2-4b3a-b36c-dd15c4969b3b)
![image](https://github.com/user-attachments/assets/e4d168be-719e-4eac-a823-af5803000ff5)
![image](https://github.com/user-attachments/assets/f94b6d32-8523-4eaa-bcd4-032a73bedb68)

- 연결 리스트는 첫 번째 위치에 데이터를 추가, 삭제하는데는 O(1)의 시간 복잡도를 갖습니다. 
- 연결 리스트는 중간 위치에 데이터를 추가, 삭제하는 데는 O(n)의 시간 복잡도를 갖습니다. ( 노드를 찾는데 O(n), 노드를 추가하는데 O(1)이 걸리기 때문에 O(n)으로 볼 수 있습니다. )

배열리스트와 연결리스트의 성능 비교 ( 정리 )
--------------------------------------------------------------------
![image](https://github.com/user-attachments/assets/c1bc92fe-5192-4001-878f-e36dea5e0e41)

- 배열 리스트는 인덱스를 통해 추가나 삭제할 위치는 O(1)으로 빠르게 찾습니다. 추가나 삭제 후에 데이터를 밀어야 하므로 O(n)으로 시간 복잡도가 커집니다.
- 연결 리스트는 인덱스를 통해 추가나 삭제할 위치는 O(n)으로 느리게 찾습니다. 하지만, 찾은 이후에는 일부 노드의 참조값만 변경하면 되서 O(n)의 시간 복잡도가 유지됩니다.
- 데이터를 앞쪽에 추가할 경우라면 연결리스트가 더 좋은 성능을 제공합니다.
- 마지막에 데이터를 추가할 경우라면 배열리스트가 더 좋은 성능을 제공합니다.

자바의 이중 연결 리스트 
---------------------------------------------------------------
- 보통 연결 리스트는 단일 연결 리스트로 위와 같은 시간 복잡도를 갖지만, 자바에서는 이중 연결 리스트라는 걸 기본으로 제공합니다.
- 이러한 이중 연결 리스트는 마지막 노드를 참조하는 변수를 가지고 있어서 뒤에 추가하거나 삭제하는 경우에도 O(1)의 시간 복잡도를 갖습니다.

```java
```java
public class LinkedList {
  private Node first;
  private Node last; // 마지막 노드 참조
  private int size = 0;
}
```
- 이중 연결 리스트라면 시작 노드와 마지막 노드를 모두 참조하기 때문에 성능이 많이 개선됩니다.

연결 리스트의 장점
------------------------------------
- 메모리 낭비 없음: 필요할 때마다 동적으로 메모리를 할당합니다.
- 데이터 추가/삭제가 빠름: 특정 위치에서 데이터를 추가/삭제할 때 O(1)의 시간 복잡도를 갖습니다. (배열은 O(n))

연결 리스트의 단점
------------------------------------
- 검색이 느림: 특정 데이터를 찾으려면 처음부터 하나씩 확인해야 합니다. O(n)의 시간 복잡도를 갖습니다.
- 추가 메모리 필요: 데이터뿐만 아니라 **다음 노드를 가리키는 포인터(참조값)**를 저장해야 하므로 메모리 사용량이 증가합니다.

![image](https://github.com/user-attachments/assets/12d1388c-7f7f-4352-86aa-34ef8a8b1d59)

단일 연결 리스트 vs 이중 연결 리스트
----------------------------------------------
- 단일 연결 리스트 : 한 방향으로만 탐색이 가능합니다. 만약 
- 이중 연결 리스트 : prev 포인터가 있어서 끝에서부터도 탐색이 가능합니다. ( 실제 LinkedList는 이중 연결로 구현되어 있습니다. )

```java
public class Node {
  Object item;
  Node next;  // 다음 노드를 가리키는 참조
}

public class Node {
  Object item;
  Node next;  // 다음 노드
  Node prev;  // 이전 노드
}
```
- 단일 연결리스트의 개별 노드는 데이터인 item과 다음 노드만을 가리키는 참조만을 갖습니다.
- 이중 연결리스트의 개별 노드는 데이터인 item과 이전, 다음 노드를 가리키는 참조를 모두 갖습니다.

자바의 LinkedList 
----------------------------------------------------
- 자바의 LinkedList는 List, Queue 인터페이스를 모두 구현해서 List처럼도 Queue처럼도 모두 사용이 가능합니다.

LinkedList의 주요 메서드
---------------------------------------------------
![image](https://github.com/user-attachments/assets/a320d422-bb75-445d-ab40-cca9a151a7b9)

 

