Set
-----------------------------------
![image](https://github.com/user-attachments/assets/5f1996e2-9dc6-4d12-b3cd-94bbd62217da)

- Set은 유일한 요소들을 저장하는 컬렉션입니다.
- Set에서는 순서가 보장되지 않습니다. ( 즉, 입력 순서와 출력 순서가 다를 수 있습니다. )
- 대신 Set은 빠른 검색에 최적화되어 있습니다.

Set을 사용하면 좋은 경우
--------------------------------
- 중복은 허용하지 않고, 요소의 유무만 중요한 경우에 Set을 사용하면 좋습니다.

기존 검색의 성능적인 문제점
-------------------------------------------------------------
![image](https://github.com/user-attachments/assets/2ada9f33-0658-4c79-96d9-497239d7c1f8)

- 기존의 배열은 index와 실제 데이터가 위 그림처럼 일치하지 않기 때문에 데이터 검색을 위해서는 순서대로 모든 데이터를 비교해야만 했습니다.

해결 방안 1 - 데이터의 값 자체를 배열의 인덱스와 맞춰서 저장하면 어떨까..?
-------------------------------------------------------------------------
![image](https://github.com/user-attachments/assets/c5fe1a6f-7ff5-44cc-be6c-86a617090d8f)

- 위 그림처럼 데이터의 값을 인덱스에 맞춰서 저장하면 검색시에도 O(1)으로 성능을 향상시킬 수 있습니다.
- 그러나 여전히 그만큼 큰 배열을 사용해야 하기에 낭비되는 메모리가 많이 발생할 수 밖에 없었습니다.

해결 방안 2 - 나머지 연산을 활용하면 어떨까..?
--------------------------------------------------------------------------
![image](https://github.com/user-attachments/assets/1941efe0-324e-45ed-8a77-18dc1c7cf386)

- 배열의 인덱스로 사용할 수 있도록 원래의 값을 계산해서 만든 인덱스를 해시 인덱스(hashIndex)라고 합니다.
- 예를 들어 14의 해시 인덱스는 4, 99의 해시 인덱스는 9가 됩니다.
- 이렇게 하면 하나의 값을 저장하는 데 성능은 O(1)으로 빠른 성능이 제공됩니다. ( 해시 인덱스 생성 O(1) + 해시 인덱스를 통한 배열에 저장 O(1) -> 시간 복잡도 O(1) )

![image](https://github.com/user-attachments/assets/2f989a7b-3497-4c34-9914-773d191d142d)

- 데이터를 조회할 때도 나머지 연산자를 사용해서 해시 인덱스를 구할 수 있습니다.
- 조회할 때는 인덱스만 해시 인덱스를 사용하고 내부에 저장된 값인 원래 값을 조회하게 됩니다.
- 검색에도 O(1)으로 빠른 성능이 제공됩니다. ( 해시 인덱스 생성 O(1) + 해시 인덱스를 통한 배열에서 값 조회 O(1) -> 시간 복잡도 O(1) )

여전한 문제점 - 해시 충돌
---------------------------------------------------------
![image](https://github.com/user-attachments/assets/c0d6eacb-a14f-49a7-94bb-44c12ce5bc98)

- 위 그림처럼 1, 11은 같은 해시 인덱스를 가지고 9, 99 역시 같은 해시 인덱스를 가지게 되어서 저장할 위치가 충돌하는 문제가 여전히 있습니다.
- 이렇게 다른 값을 입력했지만 같은 해시 코드가 나오는 문제를 해시 충돌이라고 합니다.

![image](https://github.com/user-attachments/assets/3f6e5a22-04b8-4511-9709-97bfbab5f90f)

- 이러한 해시 충돌이 발생하면 기존에 저장된 데이터가 사라지게 되어버립니다.

해결 방안 3 - 해시 충돌을 인정하자.
---------------------------------------------------------
![image](https://github.com/user-attachments/assets/7ce13730-dc4f-4ef1-b72e-4f4a6c7d7837)

- 해시 충돌을 낮은 확률로 일어날 수 있다고 가정해봅시다.
- 그러면 해시 충돌이 일어났을 때, 단순하게 같은 해시 인덱스의 값을 같은 인덱스에 함께 저장해버리면 됩니다.
- 물론 위와 같이 여러 데이터를 배열의 하나의 공간에 저장할 수는 없지만, 배열 안에 리스트 같은 자료 구조를 사용하는 것도 하나의 방법입니다.

![image](https://github.com/user-attachments/assets/d716cee8-eeee-46a2-bb68-29f5384d2432)

- 해시 충돌이 난 경우, 해당 해시 인덱스 내부의 데이터를 하나씩 비교해보면 원하는 결과를 찾을 수 있습니다.

해시 인덱스를 사용할 경우의 성능 비교 
----------------------------------------------------
![image](https://github.com/user-attachments/assets/64dcd365-5897-4c21-9f86-a1b7f3e80fe2)

- 물론 위 그림처럼 특정 해시 인덱스에만 값이 저장되는 경우는 최악의 경우 O(n)의 성능을 보입니다.
- 하지만 확률적으로 본다면 어느 정도 넓게 퍼지기 때문에 평균으로 보면 O(1)의 성능을 제공합니다.
- 즉, 다시 말해서 해시 충돌이 가끔 발생하더라도 내부에서 값을 몇 번만 비교하는 수준에서 끝나기 때문에 대부분 매우 빠르게 값을 찾을 수 있습니다.

해시의 통계적인 성능
-----------------------------------------
- 통계적으로 입력한 데이터의 수가 배열의 크기의 75%를 넘지 않으면 해시 인덱스는 자주 충돌하지 않습니다.
- 그러나, 75%를 넘으면 자주 충돌하기 시작합니다.
- 배열의 크기를 크게 하면 충돌이 줄어서 성능이 좋아지지만, 그만큼 메모리 낭비가 심하기 때문에 보통은 75%를 적절한 크기로 보고 기준을 잡는 게 효과적입니다.

해시 인덱스를 사용하는 경우 - 정리
---------------------------------------------
<table>
  <tr>
    <th></th>
    <th>데이터 저장</th>
    <th>데이터 조회</th>
  </tr>
  <tr>
    <th>평균</th>
    <td>O(1)</td>
    <td>O(1)</td>
  </tr>
  <tr>
    <th>최악</th>
    <td>O(n)</td>
    <td>O(n)</td>
  </tr>
</table>
