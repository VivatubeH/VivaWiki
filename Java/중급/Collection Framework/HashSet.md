문자를 이용한 해시 인덱스
-------------------------------------------
- 앞에서 배웠듯 해시 인덱스를 배열의 인덱스로 사용해야 하므로, 0, 1, 2와 같은 0과 양의 정수만 사용할 수 있었습니다.
- 그렇다면 만약 문자열 데이터를 저장한다면 어떻게 문자 데이터를 기반으로 숫자 해시 인덱스를 구할까요?

- 이 때는 문자가 가지는 고유한 아스키 값을 이용할 수 있습니다. 

```
A = 65
B = 66
AB = 65 + 66 = 131
```

- 모든 문자는 고유한 숫자로 표현할 수 있는데, 단순하게는 char형을 int로 캐스팅하면 문자의 고유한 숫자를 확인할 수 있습니다.

해시 코드(hashCode)
---------------------------------------------
- 문자를 기반으로 해서 고유한 숫자를 만들 수 있는데, 이렇게 만들어진 숫자를 해시 코드(hashCode)라고 합니다.
- 다르게 말하면, 특정한 데이터를 대표하는 값을 해시코드라고 표현할 수 있습니다. 
- 해시 코드는 보통 해시 함수를 통해서 만들어지게 됩니다.

![image](https://github.com/user-attachments/assets/79dba8fc-3c6e-4887-9a1b-21a01df80544)

- 해시 함수를 이용해서 해시 코드를 만들고, 그 해시 코드를 사용하면 해시 인덱스를 생성할 수 있습니다.
- 이렇게 생성된 해시 인덱스를 배열의 인덱스로 사용하면 문자를 기반으로 해서 인덱스를 생성할 수 있습니다.

해시 함수(Hash Function)
------------------------------------------------
- 해시 함수는 임의의 길이의 데이터를 입력으로 받아서 고정된 길이의 해시값(해시 코드)를 출력하는 함수를 말합니다.
- 이 때 고정된 길이는 저장 공간의 크기를 말합니다. ( 예를 들어 int형 1, 100은 둘 다 4byte를 차지하는 고정된 길이를 뜻합니다. )
- 만약 같은 데이터를 입력하면 항상 같은 해시 코드가 출력됩니다.
- 그러나 다른 데이터를 입력해도 같은 해시 코드가 출력될 수 있는데 이를 해시 충돌이라고 합니다.

```
BC = B(66) + C(67) = 133
AD = A(65) + D(68) = 133
```
- 만약 위와 같은 규칙으로 해시 코드를 구한다면 위와 같은 경우가 해시 충돌이 됩니다.

해시 인덱스(Hash Index)
--------------------------------------------------
- 해시 인덱스는 데이터의 저장 위치를 결정하는데, 주로 해시 코드를 통해 생성합니다.
- 보통은 해시 코드의 결과에 배열의 크기를 나누어서 해시 인덱스를 구합니다.

해시 코드의 핵심
--------------------------------------------------
- 어떤 타입의 객체든지 정수로 만든 해시 코드만 정의할 수 있으면 해시 인덱스를 사용할 수 있습니다.

자바의 Object.hashCode()
------------------------------------------------
- 해시 인덱스를 사용하는 자료 구조는 데이터 추가, 검색, 삭제의 성능이 해시충돌이 없는 이상 평균적으로 O(1)으로 매우 빠릅니다.
- 이렇게 성능이 뛰어난 해시 자료 구조는 자주 사용되는데, 해시 자료 구조 사용을 위해서는 정수로 된 숫자값인 해시 코드가 필수입니다.
- 그렇다면 자바의 각종 타입 뿐만 아니라 개발자가 만든 타입을 해시 코드에 정의하기 위해서는 모든 객체들이 숫자 해시 코드를 제공할 수 있어야 합니다.

- 그래서 자바에서는 모든 객체가 자신만의 해시 코드를 표현할 수 있는 메서드를 Object의 hashCode()를 통해 제공합니다.
- 이 메서드는 보통 재정의(오버라이딩)을 통해서 사용합니다.
- hashCode()의 기본 구현은 객체의 참조값을 기반으로 한 해시 코드 생성입니다. ( 즉, 객체의 인스턴스가 다르다면 해시 코드도 다릅니다. )

자바 기본 클래스의 hashCode()
-------------------------------------------------
- Integer, String 처럼 자바가 제공하는 기본 클래스들은 대부분 내부 값을 기반으로 해시 코드를 구할 수 있도록 hashCode()가 재정의 되어 있습니다.
- 그러므로 데이터의 값이 같다면, 같은 해시 코드를 반환하도록 되어 있습니다. ( 해시 코드는 정수를 반환하기 때문에 마이너스 값이 나올 수 있습니다. )

동일성과 동등성
-------------------------------------------------
- 동일성(Identity) : == 연산자를 사용해서 두 객체의 참조가 같은 객체를 가리키는지 확인합니다. ( JVM 기준으로, 물리적으로 같은지 확인합니다. )
- 동등성(Equality) : equals() 메서드를 사용해서 두 객체가 논리적으로 동등한지를 확인합니다. ( 사람의 논리적인 기준을 바탕으로 같은지 확인합니다. )

해시 자료 구조를 사용할 때 equals() 재정의의 필요성
----------------------------------------------------------
![image](https://github.com/user-attachments/assets/c3f46afb-b1ff-4e55-a8fe-f93c4e06c27b)

- 해시 자료구조를 사용할 때, 위 그림처럼 같은 해시 인덱스에 값이 저장되는 경우가 있을 수 있습니다.
- 그렇기 때문에 해시 자료구조를 사용할 때는 hashCode() 뿐만 아니라 equals()도 반드시 재정의 해야합니다.
- 자바가 제공하는 기본 클래스들에는 hashCode(), equals()가 함께 재정의 되어 있습니다.
- 특정 인덱스에 데이터가 하나만 있더라도, equals()로 찾는 데이터가 맞는지 검증해야 합니다. ( 검색 시에 필요합니다. )

해시 자료구조에서 hashCode, equals를 구현하지 않은 경우 발생할 수 있는 문제점
----------------------------------------------------------------------------
![image](https://github.com/user-attachments/assets/c93f19c2-8efd-4cdd-bf2b-5ca41fb6db0a)

- 만약 m1과 m2가 논리적으로 같더라도, 해시코드를 재정의하지 않으면 Object.hashCode()를 사용해서 단순히 참조값 비교를 하게 됩니다.
- 그렇게 되면 둘의 주소가 참조값이 다르기 때문에 각각 다른 해시 인덱스가 생성되어서 같은 데이터가 중복 저장되게 됩니다.

![image](https://github.com/user-attachments/assets/fc7ac11d-f447-4fe4-b74d-e73544ccc772)

- 데이터를 검색할 때에도, m1,m2와 논리적으로 동일한 객체를 검색하기 위해 논리적으로는 동일한 새로운 객체를 만들었어도
- 다른 위치에서 데이터를 찾게 되어서 검색에 실패하게 됩니다.

해시 자료구조에서 hashCode만 구현하고 equals는 구현하지 않은 경우 발생할 수 있는 문제점
--------------------------------------------------------------------------------------
![image](https://github.com/user-attachments/assets/fc23f972-92c7-4f0e-840f-6b608e692cf7)

- hashCode()를 재정의했다면 논리적으로 동등한 객체 m1과 m2는 같은 해시코드를 갖게 됩니다.
- 그러나, 같은 인덱스에 같은 데이터를 중복해서 저장하지 않기 위해 equals를 할 때 재정의 되어 있지 않게 되면
- 참조값을 비교하게 되어서 둘을 중복 데이터가 아니라고 생각해서 둘 모두를 중복해서 저장하게 됩니다.

![image](https://github.com/user-attachments/assets/96d9ab70-b68e-4e42-ae25-5a582449a0d0)

- 데이터를 검색할 때도, equals()가 구현되지 않았기 때문에 참조값을 비교하게 되고
- false를 반환하기 때문에 데이터를 찾을 수가 없게 됩니다.

해시 자료구조에서 hashCode와 equals를 모두 구현한 경우
-------------------------------------------------------------
![image](https://github.com/user-attachments/assets/a0a06a0e-ea87-4a09-b53d-3bbfbfb7b502)

- 논리적으로 같은 데이터면 같은 해시코드를 반환하게 되고, 같은 위치에 데이터를 저장하러 갑니다.
- equals()가 재정의 되어 있기 때문에 중복 데이터는 저장되지 않습니다.

![image](https://github.com/user-attachments/assets/3b72ba6d-f8b8-4a86-a767-5129b8c81e19)

- equals()가 재정의되어 있으면 equals 비교에 성공해서 데이터 검색도 가능해집니다.

해시 함수 사용 시 명심할 사항
----------------------------------------
- 해시 함수는 같은 입력에 대해서 반드시 동일한 해시 코드를 반환해야 합니다.
- 자바가 제공하는 해시함수를 통해서 해시 인덱스가 고루 분포되어 성능이 최적화된 해시 코드를 구할 수 있습니다.
- 그러나 이러한 경우에도 아주 간혹 같은 해시코드가 생성되어서 해시 충돌이 발생하는 경우도 간혹 존재합니다.
- 그러나, 이 때도 equals()를 이용해서 재차 비교하기 때문에 해시 코드가 충돌하더라도 큰 문제가 되지는 않습니다.

