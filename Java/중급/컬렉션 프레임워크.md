컬렉션 프레임워크(Collection Framework)
------------------------------------------------
여러 데이터(자료)를 구조화해서 다루는 것을 자료구조라고 하는데, 자바가 제공하는 자료 구조들이 바로 컬렉션 프레임워크입니다.

기존에 사용했던 배열의 특징
----------------------------------------------
- 자료를 찾을 때 index를 이용해서 빠르게 자료를 찾을 수 있었습니다.
- 인덱스를 통한 입력, 변경, 조회는 한 번의 계산으로 자료의 위치를 바로 찾을 수 있었습니다.

![image](https://github.com/user-attachments/assets/687a512e-e9bf-40c0-b591-fdaad6abb06c)

배열의 데이터 검색
----------------------------
- 배열에 들어있는 데이터를 찾는 것을 검색이라고 합니다.
- 배열에 들어있는 데이터를 검색할 때는 인덱스로 한 번에 찾을 수 없고, 대신 배열에 들어있는 데이터 하나하나 비교해야 합니다.
- 그래서 배열을 순차적으로 검색하게 되면 배열에 들어있는 데이터의 크기 만큼 연산이 필요하게 됩니다.

![image](https://github.com/user-attachments/assets/dc766ab2-74f7-4b1a-94cd-7dd042e3830f)

빅오(O) 표기법 ( 그냥 여기서는 참고로 보고, 이런 게 있구나 하고 넘어가시면 됩니다. )
-------------------------------------------------
- 알고리즘의 성능을 분석할 때 쓰는 수학적인 표현 방식입니다.
- 알고리즘이 처리해야 할 데이터 양이 증가할 때 알고리즘이 얼마나 빠르게 실행되는지를 나타냅니다.
- 여기서 핵심은 알고리즘의 정확한 실행 시간 계산이 아닌, 데이터 양 증가에 따른 성능의 변화 추세를 이해하는 것입니다.
- 참고로 빅오 표기법은 매우 큰 데이터 입력을 가정하고 성능 변화 추세를 비교하기 때문에, 보통 상수는 의미가 없어져서 상수는 제거하게 됩니다. ( 예를 들어, O(n+2)와 O(n/2)모두 O(n)으로 표시합니다. )
- 빅오 표기법은 별도 이야기가 없으면 보통 최악의 상황을 가정해서 표기합니다.

![image](https://github.com/user-attachments/assets/4e3d4f71-ae31-4c70-ac1d-a0d56b812569)

- O(1) : 상수 시간, 즉 입력 데이터의 크기에 관계없이 실행 시간이 일정한 경우를 말합니다. ( 예를 들어, 배열에서 인덱스를 이용해 한 번에 찾는 경우가 해당됩니다. )
- O(n) : 선형 시간, 즉 입력 데이터의 크기에 실행 시간이 비례해서 증가하는 경우를 말합니다. ( 예를 들어, 배열의 검색, 배열의 모든 요소 순회 등이 해당됩니다. )
- O(n^2) : 제곱 시간, 즉 입력 데이터의 크기의 제곱에 비례해서 실행 시간이 증가하는 경우를 말합니다. ( 예를 들어, 보통 이중 루프를 사용하는 알고리즘에서 나타납니다. )
- O(log n) : 로그 시간, 즉 입력 데이터의 크기의 로그에 비례해서 실행 시간이 증가하는 경우를 말합니다. ( 예를 들어, 이진 탐색이 있습니다. )
- O(n log n) : 선형 로그 시간을 말합니다. ( 예를 들어 많은 효율적인 정렬 알고리즘이 해당됩니다. )

그렇다면 배열의 검색 시 빅오 표기법은...? 
------------------------------------------
- 인덱스를 사용할 경우 : O(1)
- 배열을 순차 검색할 경우 : O(n)
- 예를 들어 100,000건 데이터가 있다면 인덱스가 있으면 1번의 연산으로 찾을 수 있지만 순차 검색을 하면 최악의 경우 100,000번 연산이 필요합니다.

배열의 데이터 추가
------------------------------------------
- 배열의 기존 데이터를 유지하면서 새로운 데이터를 입력하는 것을 추가라고 합니다.
- 만약 데이터를 중간에 추가한다면, 기존 데이터가 오른쪽으로 한 칸씩 이동해야 합니다. ( 즉, 기존 데이터의 인덱스를 하나씩 증가시켜야 합니다. )

그렇다면 배열의 데이터 추가 시 빅오 표기법은..?
-----------------------------------------------
- 첫 번째 위치에 추가할 경우 : O(n) ( 첫 위치 찾기 O(1) + 모든 데이터 이동 O(n) )
- 중간 위치에 추가할 경우 : O(n) ( 첫 위치 찾기 O(1) + index 우측 데이터 이동 O(n/2) )
- 마지막 위치에 추가할 경우 : O(1) ( 마지막 위치 찾기 O(1) )

```java
private static void addLast(int[] arr, int newValue) { // 마지막에 데이터를 추가하고자 하면
  arr[arr.length - 1] = newValue; // 단순히 마지막 인덱스를 찾아서 값을 추가하면 됩니다.
}
private static void addFirst(int[] arr, int newValue) { // 첫 번째 위치에 데이터를 추가하고자 하면
  for (int i = arr.length - 1; i > 0; i--) { // 마지막 인덱스부터 시작해서
    arr[i] = arr[i - 1]; // 앞의 값을 하나씩 뒤로 미루는 작업을 진행하고
}
    arr[0] = newValue; // 완료되면 비어있는 첫번째 인덱스에 값을 대입합니다.
}
private static void addAtIndex(int[] arr, int index, int newValue) { // 특정 위치에 데이터를 추가하고자 하면
  for (int i = arr.length - 1; i > index; i--) { // 마지막 인덱스부터 해당 인덱스까지
    arr[i] = arr[i - 1]; // 앞의 값을 하나씩 뒤로 미루는 작업을 진행하고,
}
    arr[index] = newValue; // 완료되면 비어있는 해당 인덱스에 값을 대입합니다.
```

배열이 갖는 한계
------------------------------
- 배열이 갖는 가장 큰 한계는 바로 배열의 크기를 배열을 생성하는 시점에 미리 정해야 한다는 점입니다.
- 미리 너무 크게 잡으면 메모리 낭비가 되고, 적게 잡으면 데이터를 더 이상 저장하지 못한다는 치명적인 단점이 생겨버립니다.
- 그래서, 이러한 단점을 보완하기 위해 동적으로 길이를 늘리고 줄일 수 있는 자료구조가 필요하게 되었습니다.

