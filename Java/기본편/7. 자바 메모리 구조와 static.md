## 핵심 요약

- 자바 메모리는 메서드 영역(클래스 정보 + static), 스택 영역(메서드 실행 + 지역 변수), 힙 영역(인스턴스)으로 구성된다.
- static 변수는 메서드 영역에 단 하나만 생성되며, 모든 인스턴스가 공유한다. 클래스명으로 접근한다.
- static 메서드는 인스턴스 생성 없이 호출 가능하지만, 내부에서 인스턴스 변수나 메서드를 사용할 수 없다.
- 메서드 호출 시 스택 프레임이 쌓이고, 메서드 종료 시 제거된다(LIFO 구조).

# 자바 메모리 구조

자바의 메모리 구조는 크게 3개 영역으로 나뉜다.

## 메모리 3대 영역

**메서드 영역(Method Area)**
- 클래스 정보 보관: 실행 코드(바이트코드), 필드, 메서드, 생성자 등
- static 영역: static 변수 보관
- 런타임 상수 풀: 리터럴 상수 보관
- 프로그램 전체에서 공유

**스택 영역(Stack Area)**
- 메서드 호출 시 스택 프레임 생성
- 지역 변수, 매개변수, 중간 연산 결과 저장
- 메서드 종료 시 스택 프레임 제거
- 쓰레드마다 하나씩 생성

**힙 영역(Heap Area)**
- 객체(인스턴스)와 배열 생성
- new 키워드 사용 시 이 영역 사용
- GC가 관리하는 영역

## 메서드 코드의 위치

특정 클래스로 100개 인스턴스를 생성하면, 힙에 100개 인스턴스가 생긴다. 각 인스턴스는 변수와 메서드를 가진다. 하지만 메서드는 공통 코드를 공유한다. 따라서 인스턴스가 생성될 때 변수에만 메모리가 할당되고, 메서드는 메서드 영역에서 공통으로 관리된다.

인스턴스 메서드를 호출하면 실제로는 메서드 영역에 있는 코드를 불러서 수행한다.

# 스택과 큐 자료구조

## 스택(Stack) - 후입선출(LIFO)

블럭을 위에서부터 쌓고, 위에서부터 뺀다.
```
1 넣기 → 2 넣기 → 3 넣기 → 3 빼기 → 2 빼기 → 1 빼기
```

나중에 넣은 것이 먼저 나온다.

## 큐(Queue) - 선입선출(FIFO)

한쪽에서 넣고, 반대쪽에서 뺀다.
```
1 넣기 → 2 넣기 → 3 넣기 → 1 빼기 → 2 빼기 → 3 빼기
```

먼저 넣은 것이 먼저 나온다.

# 스택 영역 동작 방식

## 메서드 호출 예제
```java
public class JavaMemoryMain1 {
    public static void main(String[] args) {
        System.out.println("main start");
        method1(10);
        System.out.println("main end");
    }
    
    static void method1(int m1) {
        System.out.println("method1 start");
        int cal = m1 * 2;
        method2(cal);
        System.out.println("method1 end");
    }
    
    static void method2(int m2) {
        System.out.println("method2 start");
        System.out.println("method2 end");
    }
}
```

**실행 결과**
```
main start
method1 start
method2 start
method2 end
method1 end
main end
```

## 스택 프레임의 생성과 제거

1. `main()` 실행 → `main()` 스택 프레임 생성 (args 포함)
2. `method1(10)` 호출 → `method1()` 스택 프레임 생성 (m1=10, cal=20 포함)
3. `method2(20)` 호출 → `method2()` 스택 프레임 생성 (m2=20 포함)
4. `method2()` 종료 → `method2()` 스택 프레임 제거, m2도 제거
5. `method1()` 종료 → `method1()` 스택 프레임 제거, m1, cal도 제거
6. `main()` 종료 → `main()` 스택 프레임 제거, 프로그램 종료

스택 프레임이 종료되면 지역 변수(매개변수 포함)도 함께 제거된다.

# 스택과 힙의 협력

## 인스턴스 생성 예제
```java
public class Data {
    private int value;
    
    public Data(int value) {
        this.value = value;
    }
    
    public int getValue() {
        return value;
    }
}
```
```java
public class JavaMemoryMain2 {
    public static void main(String[] args) {
        System.out.println("main start");
        method1();
        System.out.println("main end");
    }
    
    static void method1() {
        System.out.println("method1 start");
        Data data1 = new Data(10);
        method2(data1);
        System.out.println("method1 end");
    }
    
    static void method2(Data data2) {
        System.out.println("method2 start");
        System.out.println("data.value=" + data2.getValue());
        System.out.println("method2 end");
    }
}
```

## 메모리 동작

1. `method1()` 실행 → 스택 프레임 생성, 지역 변수 `data1` 포함
2. `new Data(10)` → 힙 영역에 Data 인스턴스 생성 (x001)
3. `data1`에 x001 참조값 저장
4. `method2(data1)` 호출 → `data2` 매개변수에 x001 전달
5. `data1`과 `data2` 모두 같은 x001 인스턴스 참조
6. `method2()` 종료 → `data2` 제거 (참조값만 제거, 인스턴스는 유지)
7. `method1()` 종료 → `data1` 제거
8. x001 인스턴스를 참조하는 변수가 없음 → GC 대상

## GC(Garbage Collection)

참조가 모두 사라진 인스턴스를 찾아서 메모리에서 제거한다. 힙 영역 내에서만 인스턴스끼리 참조하는 경우도 GC 대상이다.

# static 변수

## 문제 상황: 객체 생성 횟수 카운트

### 첫 번째 시도 - 인스턴스 변수 사용 (실패)
```java
public class Data1 {
    public String name;
    public int count;
    
    public Data1(String name) {
        this.name = name;
        count++;
    }
}
```
```java
public class DataCountMain1 {
    public static void main(String[] args) {
        Data1 data1 = new Data1("A");
        System.out.println("A count=" + data1.count);
        
        Data1 data2 = new Data1("B");
        System.out.println("B count=" + data2.count);
        
        Data1 data3 = new Data1("C");
        System.out.println("C count=" + data3.count);
    }
}
```

**실행 결과**
```
A count=1
B count=1
C count=1
```

인스턴스마다 별도의 count 변수가 생성되므로 카운트가 공유되지 않는다.

### 두 번째 시도 - 외부 객체 사용 (성공하지만 불편)
```java
public class Counter {
    public int count;
}
```
```java
public class Data2 {
    public String name;
    
    public Data2(String name, Counter counter) {
        this.name = name;
        counter.count++;
    }
}
```
```java
public class DataCountMain2 {
    public static void main(String[] args) {
        Counter counter = new Counter();
        
        Data2 data1 = new Data2("A", counter);
        System.out.println("A count=" + counter.count);
        
        Data2 data2 = new Data2("B", counter);
        System.out.println("B count=" + counter.count);
        
        Data2 data3 = new Data2("C", counter);
        System.out.println("C count=" + counter.count);
    }
}
```

**실행 결과**
```
A count=1
B count=2
C count=3
```

Counter 인스턴스를 공유해서 정확하게 카운트할 수 있다. 하지만 불편한 점이 있다.

- Data2와 관련된 일인데 Counter라는 별도 클래스 필요
- 생성자 매개변수 추가로 복잡도 증가

### 세 번째 시도 - static 변수 사용 (최적)
```java
public class Data3 {
    public String name;
    public static int count;  // static 변수
    
    public Data3(String name) {
        this.name = name;
        count++;
    }
}
```
```java
public class DataCountMain3 {
    public static void main(String[] args) {
        Data3 data1 = new Data3("A");
        System.out.println("A count=" + Data3.count);
        
        Data3 data2 = new Data3("B");
        System.out.println("B count=" + Data3.count);
        
        Data3 data3 = new Data3("C");
        System.out.println("C count=" + Data3.count);
    }
}
```

**실행 결과**
```
A count=1
B count=2
C count=3
```

## static 변수의 메모리 위치

static 변수는 메서드 영역에 단 하나만 생성된다. 인스턴스 영역에는 생성되지 않는다.

- `Data3("A")` 생성 시: 메서드 영역의 count 값 1 증가
- `Data3("B")` 생성 시: 메서드 영역의 count 값 1 증가
- `Data3("C")` 생성 시: 메서드 영역의 count 값 1 증가

최종적으로 메서드 영역의 count 값은 3이 된다.

## static 변수 접근
```java
Data3.count  // 클래스명으로 접근 (권장)
data3.count  // 인스턴스로도 접근 가능 (비권장)
```

인스턴스를 통한 접근은 인스턴스 변수와 혼동될 수 있으므로 클래스명으로 접근하는 것이 명확하다.

# 용어 정리

## 멤버 변수의 종류

**인스턴스 변수**
- static이 붙지 않은 멤버 변수
- 인스턴스를 생성해야 사용 가능
- 인스턴스마다 별도 생성
- 힙 영역에 저장

**클래스 변수 (정적 변수, static 변수)**
- static이 붙은 멤버 변수
- 인스턴스 생성 없이 사용 가능
- 프로그램 시작 시 딱 1개만 생성
- 메서드 영역의 static 영역에 저장
- 모든 인스턴스가 공유

## 변수의 생명주기

**지역 변수 (매개변수 포함)**
- 스택 프레임에 저장
- 메서드 종료 시 제거
- 생존 주기가 짧음

**인스턴스 변수**
- 힙 영역에 저장
- GC 전까지 생존
- 지역 변수보다 생존 주기가 김

**클래스 변수**
- 메서드 영역에 저장
- 클래스 로딩 시 생성
- JVM 종료 시 제거
- 가장 긴 생명주기

static이 "정적"이라 불리는 이유는 프로그램 실행 시 딱 만들어지고 종료 시 제거되기 때문이다. 인스턴스 변수는 동적으로 생성/제거되지만, static 변수는 정적이다.

# static 메서드

## 인스턴스 메서드 사용 예제
```java
public class DecoUtil1 {
    public String deco(String str) {
        String result = "*" + str + "*";
        return result;
    }
}
```
```java
public class DecoMain1 {
    public static void main(String[] args) {
        String s = "hello java";
        DecoUtil1 utils = new DecoUtil1();  // 인스턴스 생성 필요
        String deco = utils.deco(s);
        
        System.out.println("before: " + s);
        System.out.println("after: " + deco);
    }
}
```

`deco()` 메서드는 멤버 변수를 사용하지 않고 단순히 기능만 제공한다. 이런 경우 인스턴스 생성이 불필요하다.

## static 메서드 사용
```java
public class DecoUtil2 {
    public static String deco(String str) {  // static 메서드
        String result = "*" + str + "*";
        return result;
    }
}
```
```java
public class DecoMain2 {
    public static void main(String[] args) {
        String s = "hello java";
        String deco = DecoUtil2.deco(s);  // 클래스명으로 바로 호출
        
        System.out.println("before: " + s);
        System.out.println("after: " + deco);
    }
}
```

static 메서드는 객체 생성 없이 `클래스명.메서드명()` 형태로 바로 호출할 수 있다.

## static 메서드 사용 제약
```java
public class DecoData {
    private int instanceValue;
    private static int staticValue;
    
    public static void staticCall() {
        // instanceValue++;      // 컴파일 오류
        // instanceMethod();     // 컴파일 오류
        staticValue++;           // 정상
        staticMethod();          // 정상
    }
    
    public void instanceCall() {
        instanceValue++;         // 정상
        instanceMethod();        // 정상
        staticValue++;           // 정상
        staticMethod();          // 정상
    }
    
    private void instanceMethod() {
        System.out.println("instanceValue=" + instanceValue);
    }
    
    private static void staticMethod() {
        System.out.println("staticValue=" + staticValue);
    }
}
```

**static 메서드 규칙**
- static 메서드는 static만 사용 가능
- 인스턴스 변수, 인스턴스 메서드 접근 불가
- 이유: static 메서드는 참조값 없이 호출되므로 특정 인스턴스의 기능을 사용할 수 없음

**인스턴스 메서드 규칙**
- 모든 곳에서 static 호출 가능
- 인스턴스 변수, 메서드도 사용 가능

## static 메서드가 인스턴스 기능을 사용할 수 없는 이유

static 메서드는 클래스 이름으로 바로 호출하므로 참조값 개념이 없다. 특정 인스턴스의 기능을 사용하려면 참조값이 필요한데, static 메서드는 참조값 없이 호출된다.

단, 매개변수로 참조값을 직접 전달하면 사용 가능하다.
```java
public static void staticCall(DecoData data) {
    data.instanceValue++;
    data.instanceMethod();
}
```

## 용어 정리

**멤버 메서드의 종류**

**인스턴스 메서드**
- static이 붙지 않은 멤버 메서드
- 인스턴스를 생성해야 호출 가능

**클래스 메서드 (정적 메서드, static 메서드)**
- static이 붙은 멤버 메서드
- 인스턴스 생성 없이 클래스명으로 호출 가능

## static 메서드 활용

객체 생성 없이 메서드 호출만으로 필요한 기능을 수행할 때 사용한다. 주로 유틸리티성 메서드에 사용한다.

예: 수학 계산, 문자열 변환 등 인스턴스 변수 없이 입력값을 처리하는 경우

## static 메서드 접근
```java
DecoData.staticCall();  // 클래스명으로 접근 (권장)
data3.staticCall();     // 인스턴스로도 접근 가능 (비권장)
```

인스턴스를 통한 접근은 인스턴스 메서드와 혼동될 수 있으므로 클래스명으로 접근하는 것이 명확하다.

## static import

static 메서드를 자주 호출하는 경우 클래스명을 생략할 수 있다.
```java
import static static2.DecoData.staticCall;  // 특정 메서드만
import static static2.DecoData.*;           // 모든 static 멤버

public class DecoDataMain {
    public static void main(String[] args) {
        staticCall();  // 클래스명 생략 가능
        staticCall();
    }
}
```

static import는 정적 변수에도 사용 가능하다.

## main() 메서드와 static
```java
public static void main(String[] args)
```

`main()` 메서드는 static이다. 프로그램 시작점이므로 객체 생성 없이 실행되어야 하기 때문이다.

`main()`에서 같은 클래스의 다른 메서드를 호출하려면 그 메서드도 static이어야 한다.
```java
public class ValueDataMain {
    public static void main(String[] args) {
        ValueData valueData = new ValueData();
        add(valueData);
    }
    
    static void add(ValueData valueData) {  // static 필수
        valueData.value++;
        System.out.println("숫자 증가 value=" + valueData.value);
    }
}
```

# 실습 문제

## 문제1: 차량 카운터

생성한 차량 수를 출력하는 프로그램을 작성하라.
```java
public class CarMain {
    public static void main(String[] args) {
        Car car1 = new Car("K3");
        Car car2 = new Car("G80");
        Car car3 = new Car("Model Y");
        Car.showTotalCars();
    }
}
```

**실행 결과**
```
차량 구입, 이름: K3
차량 구입, 이름: G80
차량 구입, 이름: Model Y
구매한 차량 수: 3
```

**정답**
```java
public class Car {
    private static int totalCars;
    private String name;
    
    public Car(String name) {
        System.out.println("차량 구입, 이름: " + name);
        this.name = name;
        totalCars++;
    }
    
    public static void showTotalCars() {
        System.out.println("구매한 차량 수: " + totalCars);
    }
}
```

## 문제2: 수학 유틸리티 클래스

배열용 수학 유틸리티 클래스 `MathArrayUtils`를 만들어라.

**요구사항**
- `sum(int[] array)`: 배열 요소의 합
- `average(int[] array)`: 배열 요소의 평균
- `min(int[] array)`: 최소값
- `max(int[] array)`: 최대값
- 객체 생성 불가
- static import 사용 가능
```java
public class MathArrayUtilsMain {
    public static void main(String[] args) {
        int[] values = {1, 2, 3, 4, 5};
        System.out.println("sum=" + MathArrayUtils.sum(values));
        System.out.println("average=" + MathArrayUtils.average(values));
        System.out.println("min=" + MathArrayUtils.min(values));
        System.out.println("max=" + MathArrayUtils.max(values));
    }
}
```

**실행 결과**
```
sum=15
average=3.0
min=1
max=5
```

**정답**
```java
public class MathArrayUtils {
    
    private MathArrayUtils() {
        // 인스턴스 생성 방지
    }
    
    public static int sum(int[] values) {
        int total = 0;
        for (int value : values) {
            total += value;
        }
        return total;
    }
    
    public static double average(int[] values) {
        return (double) sum(values) / values.length;
    }
    
    public static int min(int[] values) {
        int minValue = values[0];
        for (int value : values) {
            if (value < minValue) {
                minValue = value;
            }
        }
        return minValue;
    }
    
    public static int max(int[] values) {
        int maxValue = values[0];
        for (int value : values) {
            if (value > maxValue) {
                maxValue = value;
            }
        }
        return maxValue;
    }
}
```

private 생성자를 사용해 외부에서 인스턴스를 생성할 수 없도록 막는다.
