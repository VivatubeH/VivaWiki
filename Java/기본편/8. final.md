## 핵심 요약
- `final` 키워드는 변수에 붙으면 값을 단 한 번만 할당할 수 있고 이후 변경 불가
- 필드 초기화 시 모든 인스턴스가 같은 값을 가지므로 `static final`로 상수화하는 것이 효율적
- 참조형 변수에 `final`을 사용하면 참조값(주소) 자체는 변경 불가하지만, 참조 대상 객체의 내부 값은 변경 가능

# final 키워드

## final 지역 변수
```java
package final1;

public class FinalLocalMain {
    public static void main(String[] args) {
        //final 지역 변수1
        final int data1;
        data1 = 10; //최초 한번만 할당 가능
        //data1 = 20; //컴파일 오류
        
        //final 지역 변수2
        final int data2 = 10;
        //data2 = 20; //컴파일 오류
        
        method(10);
    }
    
    //final 매개변수
    static void method(final int parameter) {
        //parameter = 20; //컴파일 오류
    }
}
```

지역 변수에 `final`을 붙이면 최초 한 번만 할당 가능하다. 이후 값을 변경하려고 하면 컴파일 오류가 발생한다.

매개변수에 `final`이 붙으면 메서드 내부에서 매개변수 값을 변경할 수 없다. 메서드 호출 시점의 값이 끝까지 유지된다.

## final 필드

### 생성자 초기화
```java
package final1;

public class ConstructInit {
    final int value;
    
    public ConstructInit(int value) {
        this.value = value;
    }
}
```

`final` 필드는 생성자를 통해서 한 번만 초기화할 수 있다.

### 필드 초기화
```java
package final1;

public class FieldInit {
    static final int CONST_VALUE = 10;
    final int value = 10;
}
```

필드에서 직접 초기화하면 이미 값이 설정되었기 때문에 생성자를 통한 초기화도 불가능하다.

`static` 변수에도 `final`을 선언할 수 있다.
```java
package final1;

public class FinalFieldMain {
    public static void main(String[] args) {
        //final 필드 - 생성자 초기화
        System.out.println("생성자 초기화");
        ConstructInit constructInit1 = new ConstructInit(10);
        ConstructInit constructInit2 = new ConstructInit(20);
        System.out.println(constructInit1.value);
        System.out.println(constructInit2.value);
        
        //final 필드 - 필드 초기화
        System.out.println("필드 초기화");
        FieldInit fieldInit1 = new FieldInit();
        FieldInit fieldInit2 = new FieldInit();
        FieldInit fieldInit3 = new FieldInit();
        System.out.println(fieldInit1.value);
        System.out.println(fieldInit2.value);
        System.out.println(fieldInit3.value);
        
        //상수
        System.out.println("상수");
        System.out.println(FieldInit.CONST_VALUE);
    }
}
```

**실행 결과**
```
생성자 초기화
10
20
필드 초기화
10
10
10
상수
10
```

생성자를 사용해서 `final` 필드를 초기화하면 각 인스턴스마다 다른 값을 할당할 수 있다. 생성 이후 값 변경은 불가능하다.

필드에서 초기화하는 경우 모든 인스턴스가 같은 값을 가진다. 필드 코드에 값이 미리 정해져 있기 때문이다.

모든 인스턴스가 같은 값을 사용하므로 메모리가 낭비된다. 같은 값이 계속 생성되는 것은 명확한 중복이다. 이럴 때 `static` 영역을 사용하면 좋다.

### static final

`static` 영역은 단 하나만 존재한다. `static final` 변수는 JVM 상에서 하나만 존재하므로 중복과 메모리 비효율 문제를 모두 해결할 수 있다.

필드에 `final` + 필드 초기화를 사용하는 경우 `static`을 붙여서 사용하는 것이 효과적이다.

## 상수(Constant)

상수는 변하지 않고 항상 일정한 값을 갖는 수를 말한다. 자바에서는 보통 단 하나만 존재하는 변하지 않는 고정된 값을 상수라고 한다.

상수는 `static final` 키워드를 사용한다.

### 자바 상수 특징
- `static final` 키워드 사용
- 대문자를 사용하고 구분은 `_`(언더스코어)로 한다 (관례)
- 일반적인 변수와 상수를 구분하기 위함
- 필드를 직접 접근해서 사용
- 상수는 기능이 아니라 고정된 값 자체를 사용하는 것이 목적
- 상수는 값을 변경할 수 없다. 따라서 필드에 직접 접근해도 데이터가 변하는 문제가 발생하지 않음
```java
package final1;

public class Constant {
    //수학 상수
    public static final double PI = 3.14;
    
    //시간 상수
    public static final int HOURS_IN_DAY = 24;
    public static final int MINUTES_IN_HOUR = 60;
    public static final int SECONDS_IN_MINUTE = 60;
    
    //애플리케이션 설정 상수
    public static final int MAX_USERS = 1000;
}
```

애플리케이션 안에는 다양한 상수가 존재할 수 있다. 수학, 시간 등 실생활에서 사용하는 상수부터 애플리케이션의 다양한 설정을 위한 상수들도 있다.

보통 이런 상수들은 애플리케이션 전반에서 사용되기 때문에 `public`을 자주 사용한다. 특정 위치에서만 사용된다면 다른 접근 제어자를 사용하면 된다.

상수는 중앙에서 값을 하나로 관리할 수 있다는 장점이 있다.

상수는 런타임에 변경할 수 없다. 상수를 변경하려면 프로그램을 종료하고 코드를 변경한 다음 프로그램을 다시 실행해야 한다.

### 상수 사용 예제

#### 상수 없이 사용
```java
package final1;

public class ConstantMain1 {
    public static void main(String[] args) {
        System.out.println("프로그램 최대 참여자 수 " + 1000);
        int currentUserCount = 999;
        process(currentUserCount++);
        process(currentUserCount++);
        process(currentUserCount++);
    }
    
    private static void process(int currentUserCount) {
        System.out.println("참여자 수:" + currentUserCount);
        if (currentUserCount > 1000) {
            System.out.println("대기자로 등록합니다.");
        } else {
            System.out.println("게임에 참가합니다.");
        }
    }
}
```

이 코드의 문제점:
- 프로그램 최대 참여자 수를 1000명에서 2000명으로 변경하면 2곳의 변경 포인트가 발생한다. 애플리케이션의 100곳에서 이 숫자를 사용했다면 100곳을 모두 변경해야 한다.
- 매직 넘버 문제 발생. 숫자 `1000`이 무슨 뜻인지 이해하기 어렵다.

**실행 결과**
```
프로그램 최대 참여자 수 1000
참여자 수:999
게임에 참가합니다.
참여자 수:1000
게임에 참가합니다.
참여자 수:1001
대기자로 등록합니다.
```

#### 상수 사용
```java
package final1;

public class ConstantMain2 {
    public static void main(String[] args) {
        System.out.println("프로그램 최대 참여자 수 " + Constant.MAX_USERS);
        int currentUserCount = 999;
        process(currentUserCount++);
        process(currentUserCount++);
        process(currentUserCount++);
    }
    
    private static void process(int currentUserCount) {
        System.out.println("참여자 수:" + currentUserCount);
        if (currentUserCount > Constant.MAX_USERS) {
            System.out.println("대기자로 등록합니다.");
        } else {
            System.out.println("게임에 참가합니다.");
        }
    }
}
```

`Constant.MAX_USERS` 상수를 사용했다. 프로그램 최대 참여자 수를 변경해야 하면 `Constant.MAX_USERS`의 상수 값만 변경하면 된다.

매직 넘버 문제를 해결했다. 숫자 `1000`이 아니라 `MAX_USERS`라는 변수명으로 코드를 이해할 수 있다.

## final과 참조형 변수

`final`은 변수의 값을 변경하지 못하게 막는다. 여기서 변수의 값은 기본형 변수와 참조형 변수에 따라 다르다.

- 기본형 변수: `10`, `20` 같은 값을 보관
- 참조형 변수: 객체의 참조값을 보관

`final`을 기본형 변수에 사용하면 값을 변경할 수 없다.

`final`을 참조형 변수에 사용하면 참조값을 변경할 수 없다.
```java
package final1;

public class Data {
    public int value;
}
```
```java
package final1;

public class FinalRefMain {
    public static void main(String[] args) {
        final Data data = new Data();
        //data = new Data(); //final 변경 불가 컴파일 오류
        
        //참조 대상의 값은 변경 가능
        data.value = 10;
        System.out.println(data.value);
        data.value = 20;
        System.out.println(data.value);
    }
}
```

참조형 변수 `data`에 `final`이 붙었다. 변수 선언 시점에 참조값을 할당했으므로 더는 참조값을 변경할 수 없다.
```java
//data = new Data(); //final 변경 불가 컴파일 오류
```

하지만 참조 대상 객체의 값은 변경할 수 있다.
```java
data.value = 10;
data.value = 20;
```

참조형 변수에 `final`이 붙으면 참조형 변수에 들어있는 참조값을 다른 값으로 변경하지 못한다. 다른 객체를 참조할 수 없다는 뜻이다.

하지만 `Data.value`는 `final`이 아니므로 값을 변경할 수 있다.

**정리**: 참조형 변수에 `final`이 붙으면 참조 대상 자체를 다른 대상으로 변경하지 못하는 것이지, 참조하는 대상의 값은 변경할 수 있다.

## final 활용 예제

`final`은 매우 유용한 제약이다. 특정 변수의 값을 할당한 이후에 변경하지 않아야 한다면 `final`을 사용하자.

예를 들어 고객의 `id`를 변경하면 큰 문제가 발생한다면 `final`로 선언하고 생성자로 값을 할당하자. 어디선가 실수로 `id` 값을 변경한다면 컴파일러가 문제를 찾아준다.
```java
package final1.ex;

public class Member {
    private final String id; //final 키워드 사용
    private String name;
    
    public Member(String id, String name) {
        this.id = id;
        this.name = name;
    }
    
    public void changeData(String id, String name) {
        //this.id = id; //컴파일 오류 발생
        this.name = name;
    }
    
    public void print() {
        System.out.println("id:" + id + ", name:" + name);
    }
}
```

`changeData()` 메서드에서 `final`인 `id` 값 변경을 시도하면 컴파일 오류가 발생한다.
```java
package final1.ex;

public class MemberMain {
    public static void main(String[] args) {
        Member member = new Member("myId", "kim");
        member.print();
        member.changeData("myId2", "seo");
        member.print();
    }
}
```

**실행 결과**
```
id:myId, name:kim
id:myId, name:seo
```
