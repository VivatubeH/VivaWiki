# 접근 제어자

## 핵심 개념

접근 제어자는 클래스의 필드와 메서드에 대한 외부 접근을 제한하는 키워드다. 데이터를 `private`으로 숨기고 `public` 메서드로만 접근하게 하면 잘못된 값 입력을 원천 차단할 수 있다.
```java
public class Speaker {
    private int volume;  // 외부에서 직접 수정 불가

    public void volumeUp() {
        if (volume >= 100) {
            System.out.println("최대 음량입니다.");
        } else {
            volume += 10;
        }
    }
}
```

## 접근 제어자 종류

| 접근 제어자 | 접근 범위 | 사용 위치 |
|----------|---------|---------|
| private | 같은 클래스 내부만 | 필드, 메서드, 생성자 |
| default | 같은 패키지 내부만 | 클래스, 필드, 메서드, 생성자 |
| protected | 같은 패키지 + 상속 관계 | 필드, 메서드, 생성자 |
| public | 모든 곳 | 클래스, 필드, 메서드, 생성자 |

**제한 강도**: `private` > `default` > `protected` > `public`

**클래스 레벨 제약사항**:
- 클래스는 `public` 또는 `default`만 가능
- `public` 클래스명은 파일명과 동일해야 함
- 한 파일에 `public` 클래스는 1개만 가능

## 캡슐화

데이터와 메서드를 하나로 묶고, 외부에 필요한 기능만 노출하는 설계 원칙이다.

**캡슐화 2대 원칙**:
1. 데이터는 `private`으로 숨김
2. 외부에 공개할 메서드만 `public`으로 선언
```java
public class BankAccount {
    private int balance;  // 데이터 숨김

    public void deposit(int amount) {  // 공개 메서드
        if (isAmountValid(amount)) {
            balance += amount;
        }
    }

    private boolean isAmountValid(int amount) {  // 내부 로직 숨김
        return amount > 0;
    }
}
```

## 면접 대비 핵심

**Q1. 접근 제어자를 사용하는 이유는?**
- 데이터 무결성 보장: 외부에서 잘못된 값을 직접 수정하지 못하게 차단
- 캡슐화 구현: 내부 구현을 숨기고 인터페이스만 공개
- 유지보수성 향상: 내부 로직 변경 시 외부 코드에 영향 최소화

**Q2. private 필드에 접근하려면?**
- getter/setter 메서드 사용 (public으로 선언)
- 메서드 내부에서 유효성 검증 로직 추가 가능

**Q3. default 접근 제어자란?**
- 접근 제어자를 명시하지 않으면 자동 적용됨 (package-private)
- 같은 패키지 내에서만 접근 가능
- 패키지 단위 모듈화에 유용

**Q4. 클래스에 private을 사용할 수 없는 이유는?**
- 클래스가 private이면 어디서도 사용 불가능 (의미 없음)
- 내부 클래스(inner class)는 private 사용 가능

**Q5. 캡슐화의 장점은?**
- 데이터 보호: 검증 로직을 우회한 직접 수정 차단
- 인터페이스 단순화: 외부는 공개 메서드만 알면 됨
- 변경 영향 최소화: 내부 구현 변경 시 외부 코드 수정 불필요
