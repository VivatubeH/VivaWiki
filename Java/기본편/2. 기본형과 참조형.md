# 기본형과 참조형

## 기본형 vs 참조형 분류

**기본형(Primitive Type)**
- int, long, double, boolean 등
- 변수에 실제 사용할 값을 직접 저장
- 연산 가능 (더하기, 빼기 등)
- 소문자로 시작
- null 할당 불가

**참조형(Reference Type)**
- 클래스, 배열
- 변수에 객체의 위치(참조값, 주소)를 저장
- 연산 불가 (참조값 자체는 계산할 수 없음)
- 대문자로 시작 (클래스명)
- null 할당 가능
```java
// 기본형
int a = 10;
int b = 20;
int sum = a + b; // 연산 가능

// 참조형
Student s1 = new Student();
Student s2 = new Student();
// s1 + s2; // 오류 발생 (연산 불가)

// 하지만 객체 내부의 기본형 멤버 변수는 연산 가능
s1.grade = 100;
s2.grade = 90;
int sum = s1.grade + s2.grade; // 가능
```

## 변수 대입의 대원칙

**자바는 항상 변수의 값을 복사해서 대입한다.**

기본형이든 참조형이든 동일하게 적용된다. 차이점은 복사되는 값이 무엇이냐는 것뿐이다.

### 기본형 대입
```java
int a = 10;
int b = a; // a의 값 10을 복사해서 b에 대입

a = 20; // a만 변경됨
// 결과: a = 20, b = 10 (각자 독립적)
```

변수 a의 값 10이 복사되어 b에 저장된다. 이후 a를 변경해도 b에는 영향이 없다.

### 참조형 대입
```java
Student s1 = new Student(); // x001 주소의 객체 생성
s1.value = 10;
Student s2 = s1; // s1의 참조값 x001을 복사해서 s2에 대입

// s1과 s2 모두 x001을 가리킴
s1.value = 20;
// 결과: s1.value = 20, s2.value = 20 (같은 객체를 참조)
```

변수 s1에 들어있는 참조값(x001)이 복사되어 s2에 저장된다. 따라서 s1과 s2는 같은 객체를 가리킨다. s1을 통해 값을 변경하면 s2로 접근해도 같은 값이 보인다.

## 메서드 호출과 값 복사

메서드 호출 시에도 동일한 원칙이 적용된다. 매개변수도 결국 변수이므로 값을 복사해서 전달한다.

### 기본형 메서드 호출
```java
public static void main(String[] args) {
    int a = 10;
    changePrimitive(a); // a의 값 10을 복사해서 전달
    System.out.println(a); // 10 (변경 안됨)
}

static void changePrimitive(int x) {
    x = 20; // x만 변경됨, 원본 a는 그대로
}
```

메서드 호출 과정:
1. `changePrimitive(a)` 호출 → `int x = a` → x에 10 복사
2. 메서드 내부에서 `x = 20` → x만 20으로 변경
3. 메서드 종료 후 a는 여전히 10

### 참조형 메서드 호출
```java
public static void main(String[] args) {
    Data dataA = new Data(); // x001 생성
    dataA.value = 10;
    changeReference(dataA); // 참조값 x001을 복사해서 전달
    System.out.println(dataA.value); // 20 (변경됨!)
}

static void changeReference(Data dataX) {
    dataX.value = 20; // x001 객체의 value 변경
}
```

메서드 호출 과정:
1. `changeReference(dataA)` 호출 → `Data dataX = dataA` → dataX에 x001 복사
2. 메서드 내부에서 `dataX.value = 20` → x001 객체의 value를 20으로 변경
3. dataA와 dataX 모두 x001을 가리키므로 변경사항이 원본에도 반영됨

**핵심 차이**
- 기본형: 값 자체가 복사되므로 원본 영향 없음
- 참조형: 참조값이 복사되어 같은 객체를 가리키므로 원본에 영향

## 메서드에서 객체 반환
```java
static Student createStudent(String name, int age, int grade) {
    Student student = new Student();
    student.name = name;
    student.age = age;
    student.grade = grade;
    return student; // 생성한 객체의 참조값 반환
}

public static void main(String[] args) {
    Student student1 = createStudent("학생1", 15, 90);
    // student1에 반환된 참조값이 저장됨
}
```

메서드 내부에서 생성한 객체의 참조값을 반환하면, 호출한 곳에서 그 객체를 사용할 수 있다.

실행 과정:
```
createStudent("학생1", 15, 90) → Student 객체 생성(x001) → return x001
Student student1 = x001 → student1에 x001 저장
```

## 변수의 종류와 초기화

### 변수 종류

**멤버 변수(필드)**
- 클래스에 선언
```java
public class Student {
    String name;  // 멤버 변수
    int age;      // 멤버 변수
    int grade;    // 멤버 변수
}
```

**지역 변수**
- 메서드에 선언
- 매개변수도 지역 변수의 일종
```java
public static void main(String[] args) {
    int a = 10;           // 지역 변수
    Student student1;     // 지역 변수
}

public static void changePrimitive(int x) {  // x는 매개변수(지역 변수)
    x = 20;
}
```

### 초기화 규칙

**멤버 변수: 자동 초기화**
- 인스턴스 생성 시 자동으로 초기화됨
- 숫자(int) = 0
- boolean = false
- 참조형 = null
```java
public class InitData {
    int value1;      // 자동으로 0으로 초기화
    int value2 = 10; // 명시적으로 10으로 초기화
}

InitData data = new InitData();
System.out.println(data.value1); // 0
System.out.println(data.value2); // 10
```

**지역 변수: 수동 초기화 필수**
- 반드시 직접 초기화해야 함
- 초기화하지 않으면 컴파일 에러
```java
int a; // 선언만 하고 초기화 안하면
System.out.println(a); // 컴파일 에러
```

## null

null은 "참조할 대상이 없음"을 나타내는 특별한 값이다. 참조형 변수에만 할당할 수 있다.

### null 할당과 사용
```java
Data data = null; // 아직 가리키는 객체 없음
System.out.println(data); // null

data = new Data(); // 객체 생성 후 참조값 할당
System.out.println(data); // ref.Data@x001

data = null; // 다시 null 할당 (객체 참조 해제)
System.out.println(data); // null
```

### 가비지 컬렉션(GC)
```java
Data data = new Data(); // x001 객체 생성
data = null; // data가 더이상 x001을 가리키지 않음
```

x001 객체를 아무도 참조하지 않게 되면, 해당 객체에 접근할 방법이 없다. 이런 객체는 JVM의 가비지 컬렉터가 자동으로 메모리에서 제거한다.

C/C++에서는 개발자가 직접 메모리를 해제해야 하지만, 자바는 GC가 자동으로 처리한다.

## NullPointerException

null 값에 점(.)을 찍으면 발생하는 예외다. 개발자를 가장 많이 괴롭히는 예외 중 하나다.

### 발생 예시
```java
Data data = null;
data.value = 10; // NullPointerException 발생!
```

실행 과정:
```
data.value = 10
→ null.value = 10  // data에 null이 들어있음
→ NullPointerException 발생 (참조할 객체가 없음)
```

### 멤버 변수가 null인 경우
```java
public class BigData {
    Data data;  // 자동으로 null 초기화
    int count;  // 자동으로 0 초기화
}

BigData bigData = new BigData();
System.out.println(bigData.data);         // null
System.out.println(bigData.data.value);   // NullPointerException!
```

실행 과정:
```
bigData.data.value
→ x001.data.value    // bigData는 x001
→ null.value         // x001.data는 null
→ NullPointerException
```

### 해결 방법
```java
BigData bigData = new BigData();
bigData.data = new Data(); // Data 객체 생성 후 할당
System.out.println(bigData.data.value); // 0 (정상 출력)
```

bigData.data에 실제 객체의 참조값을 할당하면 NullPointerException이 발생하지 않는다.

## 정리

1. **대원칙**: 자바는 항상 변수의 값을 복사해서 대입한다
   - 기본형: 실제 사용값 복사
   - 참조형: 참조값(주소) 복사

2. **메서드 호출**
   - 기본형: 값이 복사되므로 원본 변경 안됨
   - 참조형: 참조값이 복사되어 같은 객체를 가리키므로 원본 변경됨

3. **초기화**
   - 멤버 변수: 자동 초기화 (숫자 0, boolean false, 참조형 null)
   - 지역 변수: 수동 초기화 필수

4. **null**
   - 참조형만 할당 가능
   - null에 점(.)을 찍으면 NullPointerException
   - 아무도 참조하지 않는 객체는 GC가 자동 제거
