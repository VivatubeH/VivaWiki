## 핵심 요약
- 생성자는 객체 생성 시점에 자동으로 호출되며, 클래스명과 동일한 이름에 반환 타입이 없다는 점에서 메서드와 다르다.
- this는 인스턴스 자신의 참조값을 가리키며, 매개변수와 멤버 변수의 이름이 같을 때 둘을 구분하는 용도로 사용한다.
- 생성자가 하나도 없으면 자바가 기본 생성자를 자동 생성하지만, 생성자가 하나라도 있으면 기본 생성자를 만들지 않는다.
- this()를 사용하면 생성자 내부에서 다른 생성자를 호출할 수 있으며, 반드시 첫 줄에 작성해야 한다.

# 생성자

## 생성자가 필요한 이유

객체를 생성한 직후에는 보통 초기값을 설정해야 한다.

**초기화 메서드를 사용하는 방식**
```java
public class MemberInit {
    String name;
    int age;
    int grade;
}
```
```java
public class MethodInitMain1 {
    public static void main(String[] args) {
        MemberInit member1 = new MemberInit();
        member1.name = "user1";
        member1.age = 15;
        member1.grade = 90;
        
        MemberInit member2 = new MemberInit();
        member2.name = "user2";
        member2.age = 16;
        member2.grade = 80;
    }
}
```

객체 생성 후 초기값 설정 코드가 반복된다. 이를 메서드로 개선할 수 있다.

**초기화 메서드 도입**
```java
public class MethodInitMain2 {
    public static void main(String[] args) {
        MemberInit member1 = new MemberInit();
        initMember(member1, "user1", 15, 90);
        
        MemberInit member2 = new MemberInit();
        initMember(member2, "user2", 16, 80);
    }
    
    static void initMember(MemberInit member, String name, int age, int grade) {
        member.name = name;
        member.age = age;
        member.grade = grade;
    }
}
```

메서드로 반복을 제거했지만, `initMember()` 메서드가 `MemberInit` 객체의 데이터를 주로 다룬다. 객체 지향적으로는 데이터와 기능을 한 곳에 두는 것이 좋다.

# this

매개변수와 멤버 변수의 이름이 같을 때 둘을 구분하기 위해 사용한다.

## this를 사용한 초기화 메서드
```java
public class MemberInit {
    String name;
    int age;
    int grade;
    
    void initMember(String name, int age, int grade) {
        this.name = name;
        this.age = age;
        this.grade = grade;
    }
}
```
```java
public class MethodInitMain3 {
    public static void main(String[] args) {
        MemberInit member1 = new MemberInit();
        member1.initMember("user1", 15, 90);
        
        MemberInit member2 = new MemberInit();
        member2.initMember("user2", 16, 80);
    }
}
```

## this의 역할

**매개변수와 멤버 변수 구분**
```java
void initMember(String name, int age, int grade) {
    this.name = name;  // this.name은 멤버 변수, name은 매개변수
    this.age = age;
    this.grade = grade;
}
```

메서드 내부에서 `name`이라고만 쓰면 더 가까운 지역변수(매개변수)를 가리킨다. 멤버 변수에 접근하려면 `this.name`처럼 `this`를 붙여야 한다.

**실행 과정**
```java
this.name = name;
// 1. 오른쪽 name은 매개변수에 접근
this.name = "user1";
// 2. 매개변수 값 사용
x001.name = "user1";
// 3. this는 인스턴스 자신의 참조값(x001)을 가리킴
```

**this 제거 시**
```java
void initMember(String name, int age, int grade) {
    name = name;  // 둘 다 매개변수를 가리킴 (멤버 변수 변경 안됨)
    age = age;
    grade = grade;
}
```

`this`를 제거하면 모두 매개변수를 가리키므로 멤버 변수가 변경되지 않는다.

## this 생략

매개변수와 멤버 변수의 이름이 다르면 `this`를 생략할 수 있다.
```java
public class MemberThis {
    String nameField;
    
    void initMember(String nameParameter) {
        nameField = nameParameter;  // this 생략 가능
    }
}
```

변수를 찾을 때:
1. 먼저 지역변수(매개변수 포함)에서 찾음
2. 없으면 멤버 변수에서 찾음
3. 멤버 변수도 없으면 오류

## this와 코딩 스타일

**항상 this를 사용하는 스타일**
```java
public class MemberThis {
    String nameField;
    
    void initMember(String nameParameter) {
        this.nameField = nameParameter;  // 생략 가능하지만 명시
    }
}
```

과거에는 멤버 변수임을 명확히 하기 위해 항상 `this`를 붙이는 스타일도 많이 사용했다. 하지만 최근 IDE는 멤버 변수와 지역 변수를 색상으로 구분해주므로, 이름이 중복되는 경우에만 `this`를 사용해도 충분하다.

# 생성자

객체를 생성하자마자 즉시 필요한 기능을 수행할 수 있도록 하는 특별한 메서드다.

## 생성자 정의
```java
public class MemberConstruct {
    String name;
    int age;
    int grade;
    
    // 생성자
    MemberConstruct(String name, int age, int grade) {
        System.out.println("생성자 호출 name=" + name + ",age=" + age + ",grade=" + grade);
        this.name = name;
        this.age = age;
        this.grade = grade;
    }
}
```

**생성자의 특징**
- 생성자 이름은 클래스 이름과 동일 (첫 글자 대문자)
- 반환 타입이 없음 (void도 쓰지 않음)
- 나머지는 메서드와 동일

## 생성자 호출
```java
public class ConstructMain1 {
    public static void main(String[] args) {
        MemberConstruct member1 = new MemberConstruct("user1", 15, 90);
        MemberConstruct member2 = new MemberConstruct("user2", 16, 80);
    }
}
```

**실행 결과**
```
생성자 호출 name=user1,age=15,grade=90
생성자 호출 name=user2,age=16,grade=80
```

**호출 방식**
```java
new 생성자이름(생성자에 맞는 인수 목록)
new 클래스이름(생성자에 맞는 인수 목록)
```

생성자 이름이 클래스 이름이므로 둘 다 맞는 표현이다.

`new` 키워드로 객체를 생성할 때 `()` 괄호를 포함하는 이유가 바로 생성자를 호출하기 때문이다.

## 생성자의 장점

### 1. 중복 호출 제거

**생성자 등장 전**
```java
MemberInit member = new MemberInit();
member.initMember("user1", 15, 90);  // 별도로 메서드 호출 필요
```

**생성자 등장 후**
```java
MemberConstruct member = new MemberConstruct("user1", 15, 90);  // 한 번에 처리
```

객체 생성과 초기화를 한 번에 처리할 수 있다.

### 2. 제약 - 생성자 호출 필수

생성자가 정의되어 있으면 반드시 호출해야 한다.
```java
// 컴파일 오류 발생
MemberConstruct member = new MemberConstruct();  
member.name = "user1";
```

**컴파일 오류 메시지**
```
no suitable constructor found for MemberConstruct(no arguments)
```

생성자를 정의하면 객체 생성 시 필수 값 입력을 강제할 수 있다. 이를 통해 아무 정보가 없는 "유령 객체"가 시스템에 등장하는 것을 원천 차단한다.

**핵심**: 좋은 프로그램은 무한한 자유도가 아니라 적절한 제약이 있는 프로그램이다.

# 기본 생성자

## 자동 생성되는 기본 생성자

생성자를 하나도 정의하지 않으면 자바 컴파일러가 기본 생성자를 자동으로 만들어준다.
```java
public class MemberInit {
    String name;
    int age;
    int grade;
    // 생성자 없음
}
```
```java
public class MethodInitMain1 {
    public static void main(String[] args) {
        MemberInit member1 = new MemberInit();  // 기본 생성자 호출 가능
    }
}
```

자바가 자동으로 다음과 같은 기본 생성자를 만들어준다 (눈에 보이지 않음).
```java
public class MemberInit {
    String name;
    int age;
    int grade;
    
    // 자바가 자동으로 생성한 기본 생성자
    public MemberInit() {
    }
}
```

## 기본 생성자 규칙

**기본 생성자**: 매개변수가 없는 생성자

**규칙**
1. 클래스에 생성자가 하나도 없으면 → 자바가 기본 생성자 자동 생성
2. 생성자가 하나라도 있으면 → 자바가 기본 생성자를 만들지 않음

## 기본 생성자 예제
```java
public class MemberDefault {
    String name;
    // 생성자 없음
}
```
```java
public class MemberDefaultMain {
    public static void main(String[] args) {
        MemberDefault memberDefault = new MemberDefault();  // 작동함
    }
}
```

생성자가 없으므로 자바가 기본 생성자를 자동으로 만들어준다.

## 직접 정의한 기본 생성자
```java
public class MemberDefault {
    String name;
    
    MemberDefault() {
        System.out.println("생성자 호출");
    }
}
```

기본 생성자를 직접 정의할 수도 있다.

## 기본 생성자를 자동으로 만들어주는 이유

생성자 기능이 필요하지 않은 경우에도 모든 클래스에 기본 생성자를 일일이 작성해야 한다면 번거롭다. 생성자를 사용하지 않는 경우도 많기 때문에 자바가 편의 기능을 제공한다.

## 정리

- 생성자는 반드시 호출되어야 한다
- 생성자가 없으면 기본 생성자가 제공된다
- 생성자가 하나라도 있으면 기본 생성자가 제공되지 않는다 (직접 정의한 생성자를 호출해야 함)

# 생성자 오버로딩

생성자도 메서드처럼 매개변수만 다르게 해서 여러 개 정의할 수 있다.

## 생성자 오버로딩 예제
```java
public class MemberConstruct {
    String name;
    int age;
    int grade;
    
    // 생성자 1
    MemberConstruct(String name, int age) {
        this.name = name;
        this.age = age;
        this.grade = 50;  // 기본값
    }
    
    // 생성자 2
    MemberConstruct(String name, int age, int grade) {
        System.out.println("생성자 호출 name=" + name + ",age=" + age + ",grade=" + grade);
        this.name = name;
        this.age = age;
        this.grade = grade;
    }
}
```

## 오버로딩된 생성자 사용
```java
public class ConstructMain2 {
    public static void main(String[] args) {
        MemberConstruct member1 = new MemberConstruct("user1", 15, 90);
        MemberConstruct member2 = new MemberConstruct("user2", 16);
        
        MemberConstruct[] members = {member1, member2};
        for (MemberConstruct s : members) {
            System.out.println("이름:" + s.name + " 나이:" + s.age + " 성적:" + s.grade);
        }
    }
}
```

**실행 결과**
```
생성자 호출 name=user1,age=15,grade=90
이름:user1 나이:15 성적:90
이름:user2 나이:16 성적:50
```

성적이 필요한 경우 3개 매개변수 생성자를, 그렇지 않은 경우 2개 매개변수 생성자를 호출하면 된다.

# this()

생성자 내부에서 다른 생성자를 호출할 때 사용한다.

## 코드 중복 문제
```java
public MemberConstruct(String name, int age) {
    this.name = name;
    this.age = age;
    this.grade = 50;
}

public MemberConstruct(String name, int age, int grade) {
    this.name = name;
    this.age = age;
    this.grade = grade;
}
```

다음 부분이 중복된다:
```java
this.name = name;
this.age = age;
```

## this()를 사용한 중복 제거
```java
public class MemberConstruct {
    String name;
    int age;
    int grade;
    
    MemberConstruct(String name, int age) {
        this(name, age, 50);  // 다른 생성자 호출
    }
    
    MemberConstruct(String name, int age, int grade) {
        System.out.println("생성자 호출 name=" + name + ",age=" + age + ",grade=" + grade);
        this.name = name;
        this.age = age;
        this.grade = grade;
    }
}
```

**호출 흐름**
```
MemberConstruct(String name, int age) 
    → MemberConstruct(String name, int age, int grade)
```

`this()`를 사용하면 첫 번째 생성자에서 두 번째 생성자를 호출할 수 있다. 코드 중복이 제거되고 유지보수가 쉬워진다.

## this() 규칙

**this()는 생성자 코드의 첫 줄에만 작성할 수 있다**

**잘못된 예시 (컴파일 오류)**
```java
public MemberConstruct(String name, int age) {
    System.out.println("go");  // 다른 코드가 먼저 있음
    this(name, age, 50);  // 오류: this()가 첫 줄이 아님
}
```

`this()`가 첫 줄에 없으면 컴파일 오류가 발생한다.

# 정리

**생성자**
- 객체 생성 직후 객체를 초기화하기 위한 특별한 메서드
- 클래스명과 동일한 이름, 반환 타입 없음
- 객체 생성 시 자동으로 호출됨

**this**
- 인스턴스 자신의 참조값을 가리킴
- 매개변수와 멤버 변수의 이름이 같을 때 구분하기 위해 사용
- 필요한 경우에만 사용 (IDE가 색상으로 구분해주므로)

**기본 생성자**
- 매개변수가 없는 생성자
- 생성자가 하나도 없으면 자바가 자동 생성
- 생성자가 하나라도 있으면 자동 생성 안됨

**this()**
- 생성자 내부에서 다른 생성자 호출
- 반드시 첫 줄에 작성
- 생성자 오버로딩 시 코드 중복 제거에 유용

**생성자의 핵심 장점**
- 객체 생성과 초기화를 한 번에 처리
- 필수 값 입력을 강제하여 유효하지 않은 객체 생성 방지
- 컴파일 타임에 오류 확인 가능
