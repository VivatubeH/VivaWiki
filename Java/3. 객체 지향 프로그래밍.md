## 핵심 요약
- 절차 지향은 **데이터와 기능이 분리되어 실행 순서**에 초점을 맞추고, 객체 지향은 **데이터와 기능을 하나의 객체로 묶어 "무엇을" 중심으로 설계**한다.
- 클래스는 속성(멤버 변수)뿐만 아니라 기능(메서드)도 포함할 수 있으며, 객체는 **자신의 메서드로 자신의 멤버 변수에 접근**한다.
- 캡슐화는 속성과 기능을 하나로 묶어 **필요한 기능만 메서드로 외부에 제공하는 것**으로, 내부 구현 변경 시 외부 코드에 영향을 주지 않는다.

# 절차 지향 vs 객체 지향

## 절차 지향 프로그래밍

**정의**: 실행 순서를 중요하게 생각하는 방식. "어떻게"에 초점

**특징**
- 프로그램의 흐름을 순차적으로 처리
- 데이터와 기능(처리 방식)이 분리되어 있음
- 함수들이 데이터를 매개변수로 받아 처리

## 객체 지향 프로그래밍

**정의**: 객체를 중요하게 생각하는 방식. "무엇을"에 초점

**특징**
- 실제 세계의 사물을 객체로 모델링
- 데이터와 그 데이터를 처리하는 메서드가 하나의 객체 안에 존재
- 객체들 간의 상호작용으로 프로그램 구성

## 핵심 차이점

절차 지향과 객체 지향은 대치 개념이 아니다. 어디에 초점을 맞추느냐의 차이다.

- 절차 지향: 데이터 따로, 기능 따로
- 객체 지향: 데이터 + 기능을 하나의 객체로 묶음

# 절차 지향에서 객체 지향으로

음악 플레이어 예제를 통해 절차 지향 코드가 객체 지향 코드로 발전하는 과정을 살펴본다.

## 1단계: 절차 지향 방식
```java
public class MusicPlayerMain1 {
    public static void main(String[] args) {
        int volume = 0;
        boolean isOn = false;
        
        // 음악 플레이어 켜기
        isOn = true;
        System.out.println("음악 플레이어를 시작합니다");
        
        // 볼륨 증가
        volume++;
        System.out.println("음악 플레이어 볼륨:" + volume);
        
        // 볼륨 증가
        volume++;
        System.out.println("음악 플레이어 볼륨:" + volume);
        
        // 볼륨 감소
        volume--;
        System.out.println("음악 플레이어 볼륨:" + volume);
        
        // 음악 플레이어 상태
        if (isOn) {
            System.out.println("음악 플레이어 ON, 볼륨:" + volume);
        } else {
            System.out.println("음악 플레이어 OFF");
        }
        
        // 음악 플레이어 끄기
        isOn = false;
        System.out.println("음악 플레이어를 종료합니다");
    }
}
```

단순하게 순서대로 작동하는 프로그램이다.

## 2단계: 데이터 묶음

관련된 데이터를 클래스로 묶는다.
```java
public class MusicPlayerData {
    int volume = 0;
    boolean isOn = false;
}
```
```java
public class MusicPlayerMain2 {
    public static void main(String[] args) {
        MusicPlayerData data = new MusicPlayerData();
        
        // 음악 플레이어 켜기
        data.isOn = true;
        System.out.println("음악 플레이어를 시작합니다");
        
        // 볼륨 증가
        data.volume++;
        System.out.println("음악 플레이어 볼륨:" + data.volume);
        
        // 볼륨 증가
        data.volume++;
        System.out.println("음악 플레이어 볼륨:" + data.volume);
        
        // 볼륨 감소
        data.volume--;
        System.out.println("음악 플레이어 볼륨:" + data.volume);
        
        // 상태 확인 및 종료
        // ...
    }
}
```

음악 플레이어 관련 데이터를 `MusicPlayerData` 객체로 묶었다. 변수들이 흩어져 있지 않고 하나의 객체로 관리된다.

## 3단계: 메서드 추출

중복되는 기능을 메서드로 분리한다.
```java
public class MusicPlayerMain3 {
    public static void main(String[] args) {
        MusicPlayerData data = new MusicPlayerData();
        
        // 음악 플레이어 켜기
        on(data);
        
        // 볼륨 증가
        volumeUp(data);
        volumeUp(data);
        
        // 볼륨 감소
        volumeDown(data);
        
        // 음악 플레이어 상태
        showStatus(data);
        
        // 음악 플레이어 끄기
        off(data);
    }
    
    static void on(MusicPlayerData data) {
        data.isOn = true;
        System.out.println("음악 플레이어를 시작합니다");
    }
    
    static void off(MusicPlayerData data) {
        data.isOn = false;
        System.out.println("음악 플레이어를 종료합니다");
    }
    
    static void volumeUp(MusicPlayerData data) {
        data.volume++;
        System.out.println("음악 플레이어 볼륨:" + data.volume);
    }
    
    static void volumeDown(MusicPlayerData data) {
        data.volume--;
        System.out.println("음악 플레이어 볼륨:" + data.volume);
    }
    
    static void showStatus(MusicPlayerData data) {
        System.out.println("음악 플레이어 상태 확인");
        if (data.isOn) {
            System.out.println("음악 플레이어 ON, 볼륨:" + data.volume);
        } else {
            System.out.println("음악 플레이어 OFF");
        }
    }
}
```

**메서드 추출의 장점**
- 중복 제거: 같은 로직을 여러 번 호출 가능
- 변경 영향 범위: 메서드 내부만 수정하면 됨
- 메서드 이름 추가: 코드의 가독성 향상
- 모듈화: 필요한 기능을 조립해서 사용 가능

## 절차 지향의 한계

여기까지 코드는 깔끔하고 유지보수하기 좋아 보이지만 한계가 있다.

**문제점**: 데이터와 기능이 분리되어 있다
- 데이터: `MusicPlayerData` 클래스
- 기능: `MusicPlayerMain3`의 각 메서드

데이터와 그 데이터를 사용하는 기능은 매우 밀접하게 연관되어 있다. 데이터가 변경되면 관련 메서드도 모두 변경해야 한다. 관리 포인트가 2곳으로 늘어난다.

# 클래스와 메서드

클래스는 데이터(멤버 변수)뿐만 아니라 기능(메서드)도 포함할 수 있다.

## 멤버 변수만 있는 클래스
```java
public class ValueData {
    int value;
}
```
```java
public class ValueDataMain {
    public static void main(String[] args) {
        ValueData valueData = new ValueData();
        add(valueData);
        add(valueData);
        add(valueData);
        System.out.println("최종 숫자=" + valueData.value);
    }
    
    static void add(ValueData valueData) {
        valueData.value++;
        System.out.println("숫자 증가 value=" + valueData.value);
    }
}
```

데이터(`value`)와 기능(`add()`)이 분리되어 있다.

## 메서드를 포함한 클래스
```java
public class ValueObject {
    int value;
    
    void add() {
        value++;
        System.out.println("숫자 증가 value=" + value);
    }
}
```
```java
public class ValueObjectMain {
    public static void main(String[] args) {
        ValueObject valueObject = new ValueObject();
        valueObject.add();
        valueObject.add();
        valueObject.add();
        System.out.println("최종 숫자=" + valueObject.value);
    }
}
```

데이터와 기능이 하나의 클래스에 함께 존재한다.

## 인스턴스 메서드 호출 과정
```java
valueObject.add(); // 1. 메서드 호출
```

실행 과정:
1. `valueObject.add()` 호출
2. `x002.add()` - x002 ValueObject 인스턴스의 add() 메서드 호출
3. 메서드 내부에서 `value++` 실행 시 본인 인스턴스의 멤버 변수에 접근
4. `x002.value`에 접근하여 값을 증가시킴

**핵심**: 객체의 메서드는 자신(this)의 멤버 변수에 접근한다.

# 객체 지향 프로그래밍

이제 음악 플레이어를 온전한 객체로 만들어보자. 프로그램 실행 순서보다 음악 플레이어라는 "객체 자체"에 초점을 맞춘다.

## 객체 지향 음악 플레이어
```java
public class MusicPlayer {
    int volume = 0;
    boolean isOn = false;
    
    void on() {
        isOn = true;
        System.out.println("음악 플레이어를 시작합니다");
    }
    
    void off() {
        isOn = false;
        System.out.println("음악 플레이어를 종료합니다");
    }
    
    void volumeUp() {
        volume++;
        System.out.println("음악 플레이어 볼륨:" + volume);
    }
    
    void volumeDown() {
        volume--;
        System.out.println("음악 플레이어 볼륨:" + volume);
    }
    
    void showStatus() {
        System.out.println("음악 플레이어 상태 확인");
        if (isOn) {
            System.out.println("음악 플레이어 ON, 볼륨:" + volume);
        } else {
            System.out.println("음악 플레이어 OFF");
        }
    }
}
```

음악 플레이어에 필요한 모든 속성과 기능이 하나의 클래스에 포함되어 있다.

## 객체 지향 방식 사용
```java
public class MusicPlayerMain4 {
    public static void main(String[] args) {
        MusicPlayer player = new MusicPlayer();
        
        // 음악 플레이어 켜기
        player.on();
        
        // 볼륨 증가
        player.volumeUp();
        player.volumeUp();
        
        // 볼륨 감소
        player.volumeDown();
        
        // 음악 플레이어 상태
        player.showStatus();
        
        // 음악 플레이어 끄기
        player.off();
    }
}
```

**특징**
- `MusicPlayer` 객체만 생성하면 모든 기능 사용 가능
- 사용하는 입장에서 내부 데이터(`volume`, `isOn`)를 전혀 몰라도 됨
- 제공하는 메서드만 호출하면 됨

# 캡슐화(Encapsulation)

속성과 기능을 하나로 묶어서 필요한 기능을 메서드를 통해 외부에 제공하는 것

**캡슐화의 장점**

1. **내부 구현 은닉**
   - 사용자는 내부 데이터 구조를 몰라도 됨
   - `volume`, `isOn` 같은 내부 속성을 직접 다룰 필요 없음

2. **변경 용이성**
   - `MusicPlayer` 내부 구현이 변경되어도 외부 코드는 변경 불필요
   - 예: `volume` 필드명 변경 → `MusicPlayer` 내부만 수정
   - 예: 출력 메시지 변경 → `MusicPlayer` 내부만 수정

3. **코드 응집도 향상**
   - 관련된 데이터와 기능이 한 곳에 모여있음
   - 유지보수 포인트가 한 곳으로 집중됨

# 객체란

세상의 모든 사물은 속성(데이터)과 기능 2가지로 단순화할 수 있다.

## 예시

**자동차**
- 속성: 차량 색상, 현재 속도
- 기능: 엑셀, 브레이크, 문 열기, 문 닫기

**동물**
- 속성: 색상, 키, 온도
- 기능: 먹는다, 걷는다

**게임 캐릭터**
- 속성: 레벨, 경험치, 소유 아이템
- 기능: 이동, 공격, 아이템 획득

객체 지향 프로그래밍은 모든 사물을 속성과 기능을 가진 객체로 생각하는 것이다. 이렇게 단순화하면 실세계의 사물을 컴퓨터 프로그램으로 쉽게 설계할 수 있다.

**주의**: 실세계와 객체가 항상 1:1 매칭되는 것은 아니다.

# 정리

## 절차 지향 vs 객체 지향

**절차 지향 프로그래밍**
- "어떻게"에 초점
- 실행 순서 중시
- 데이터와 기능이 분리

**객체 지향 프로그래밍**
- "무엇을"에 초점
- 객체의 설계와 관계 중시
- 데이터와 기능이 하나의 객체로 통합

## 객체 지향의 특징

1. **캡슐화**: 속성과 기능을 하나로 묶음
2. **상속**: (추후 학습)
3. **다형성**: (추후 학습)
4. **추상화**: (추후 학습)
5. **메시지 전달**: (추후 학습)

## 객체 지향 프로그래밍의 장점

- 코드 재사용성 향상
- 유지보수 용이
- 코드 가독성 향상
- 실세계 모델링 용이
- 대규모 프로젝트에 적합

현재는 객체 지향 프로그래밍이 가장 널리 사용되는 패러다임이다.
